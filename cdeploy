#!/usr/bin/env bash


###########################################################################################
##
##  cdeploy – Ein einfaches Installationsprogramm
##
##  Das Skript wurde als einfaches Hilfstool für Administratoren entwickelt, die häufig
##  ihre persönlichen Skripte und Daten auf zu wartenden Rechnern installieren müssen.
##
##  Features:
##  - einfach zu pflegende Installationspakete; bestehen aus gewöhnlichen Verzeichnissen
##  - globale (für alle Benutzer) oder lokale Installation
##  - Aktionen 'install' und 'remove'
##
##  Copyright (c) 2025 Christian Dorn
##  Alle Rechte vorbehalten.
##
## ========================================================================================
##
##  STRUKTUR
##  - Skript-Einstellungen
##  - Globale Variablen & Konstanten
##  - main()-Methode
##  - Dispatcher-Methoden
##  - Hilfsmethoden
##  - main()-Methode aufrufen
##
## ========================================================================================
##
##  RICHTLINIEN
##  - FOO_BAR   : globale Variable
##  - _FOO_BAR  : globale Konstante (readonly-Variable)
##  - foo_bar   : lokale Variable
##  - _foo_bar  : lokale Konstante (readonly-Variable)
##  - fooBar    : Methode
##
###########################################################################################




## ========================================================================================
## SKRIPT-EINSTELLUNGEN
## ========================================================================================

## Skript bei Bedarf im POSIX-Modus ausführen. Dazu müssen auch sämtliche Bash-spezifische
## Anweisungen durch POSIX-kompatible ersetzt werden!
#set -o posix


## Einstellungen für 'micro' Codeeditor (Einstellungen werden als Kommentare geschrieben!)
# shellcheck disable=SC2317     # Fehler: Befehl unerreichbar


# Abbruchkriterien für das Skript
#   -e          : Abbrechen wenn eine Anweisung einen Returncode ≠ 0 liefert.
#   -u          : Abbrechen wenn auf eine nicht definierte Variable zugegriffen wird.
#   -o pipefail : Eine Pipeline beim ersten Fehler abbrechen, nicht erst beim Letzten.
set -euo pipefail


# Feldseparator anpassen. Leerzeichen gelten anschließend nicht mehr als Trennzeichen
# -> Vorteil beim Parsen von Pfaden mit Leerzeichen.
IFS=$'\n\t'


# Es soll verhindert werden, dass ein noch aktives 'sudo' eine globale (De-)Installation
# ermöglicht. Aus diesem Grund werden alle aktiven 'sudo'-Sitzungen deaktiviert; das Skript
# muss bei Bedarf um eine neue Autorisierung bitten.
sudo -k




## ========================================================================================
## Globale Variablen & Kontanten
## ========================================================================================

# Konstanten
readonly _SCRIPT_NAME="cdeploy"
readonly _SCRIPT_VERSION="1.0"
readonly _PACK_EXT=".cdp"       # Extension für Paket-Archive
readonly _PACK_EXT_RE="\\.cdp"  # ...zur Verwendung mit RegEx

# Skript-Konfiguration
PROJECT_NAME="tools"
PROJECT_VERSION=""
PROJECT_CREATOR=""
PROJECT_URL=""
PROJECT_COPYRIGHT=""
PROJECT_DESCRIPTION=""

ACTION=""
BASE_GLOBAL="/usr/local"
BASE_LOCAL="$HOME/.local"
COUNT_CPY=0
COUNT_ERR=0
COUNT_WRN=0
ENV_PATH_SET=0
MANIFEST_FILE=""
OPT_COMPRESSED=0
OPT_DRYRUN=0
OPT_QUIET=0
OPT_SCOPE=""
OPT_USEHOOKS=0
OPT_VERBOSE=0
OUTPUT=""
OUTPUT_FORMATTED=1
PACKAGE=""
PACKAGE_SOURCE=""
PACKAGE_INPUT=""
SHOW_SYNOPSIS=0
TARGET_BASE=""
TARGET_BIN=""
TARGET_ETC=""
TARGET_LIB=""
TARGET_MAN=""
TARGET_MANIFEST=""
TARGET_SYM=""
USE_PAGER=0
USE_SUDO=""

declare -ga TEMP_OBJECTS=()

# Formatierungen
readonly _BOLD="\033[1m"
readonly _UNDER="\033[4m"
readonly _BLINK="\033[5m"
readonly _INVERT="\033[7m"
readonly _RESET="\033[0m"




## ========================================================================================
## main()-Methode
## ========================================================================================
main() {
    # Sicherstellen dass beim Beenden oder Abbrechen des Skriptes korrekt aufgeräumt wird.
    # Nur der Abbruch mit SIGKILL ('kill -9') lässt sich nicht abfangen.
    trap finalCleanup EXIT INT TERM HUP


    # Parameter parsen
    parseParameters "$@"


    # Aktion ausführen
    case "$ACTION" in
        create)
            cdeployCreate ;;
        help)
            cdeployShowHelpAndExit ;;
        info)
            cdeployShowPackageInfo ;;
        install)
            cdeployInstall ;;
        list)
            cdeployList ;;
        pack)
            cdeployPack ;;
        remove)
            cdeployRemove ;;
        version)
            cdeployShowVersionAndExit ;;
        *)
            showSyntaxAndExit "Ungültige oder unvolständige Anweisung" ;;
    esac

    quit 0
}


parseParameters() {
    # Wenn keine Parameter übergeben wurden, Syntax anzeigen und beenden
    if [[ $# -lt 1 ]]; then
        showSyntaxAndExit
    fi


    # Aktion auslesen; diese muss immer als erster Parameter gesetzt werden;
    # Syntax anzeigen und abbrechen, wenn eine unbekannte Aktion gefunden wird
    case "$1" in
        create)                 ACTION="create" ;;
        help|-h|--help)         ACTION="help" ;;
        info)                   ACTION="info" ;;
        install)                ACTION="install" ;;
        list|ls)                ACTION="list" ;;
        pack)                   ACTION="pack" ;;
        remove)                 ACTION="remove" ;;
        version|-V|--version)   ACTION="version" ;;
        *)                      showSyntaxAndExit "Unbekannte Aktion: $1" ;;
    esac

    shift  # ersten Parameter entfernen


    # Einige Aktionen benötigen keine weiteren Parameter. Bei diesen können wir hier
    # abbrechen. Sollten bei diesen Aktionen noch weitere Parameter angegeben sein,
    # wird eine Fehlermeldung ausgegeben.
    if [[ "$ACTION" =~ ^(help|list|version)$ ]]; then
        if [[ $# -gt 0 ]]; then
            showSyntaxAndExit "Diese Aktion benötigt keine Parameter: $ACTION"
        fi
        return 0
    fi

    # Alle anderen Aktionen benötigen weitere Parameter. Eine Fehlermeldung ausgeben
    # und abbrechen, Wenn keine Parameter mehr vorhanden sind.
    if [[ $# -lt 1 ]]; then
        showSyntaxAndExit "Ungültige oder unvollständige Anweisung"
    fi

    # Aktionen, die als letzten Parameter ein Installationspaket erwarten
    if [[ "$ACTION" =~ ^(info|install|pack)$ ]]; then
        PACKAGE="${!#}"
        PACKAGE_INPUT="$PACKAGE"   # zur Anzeige für den Fall, dass $PACKAGE entpackt wird
        PACKAGE_SOURCE="$PACKAGE"  # zur Berechnung des Hash
        set -- "${@:1:$(($#-1))}"  # letzten Parameter entfernen

        # Datei herunterladen, wenn $PACKAGE eine URL ist
        # (http://, https://, ftp:// oder file://)
        local result
        result="$(downloadIfURL "$PACKAGE")" || showError $? "$result"
        PACKAGE="$result"

        # Datei extrahieren, wenn sie ein Archiv ist. Sicherstellen dass PACKAGE_SOURCE auf
        # das Archiv verweist, und nicht auf das entpackte Paket. Diese Information wird
        # zur Berechnung des Hash benötigt.
        result="$(extractPackage "$PACKAGE")" || showError $? "$result"
        PACKAGE_SOURCE="$PACKAGE"
        PACKAGE="$result"

        # Pfad prüfen und zurückgeben
        if [ "$PACKAGE" = "" ]; then
            showError 1 "Der Paketpfad konnte nicht korrekt verarbeitet werden."
        elif ! checkPackage; then
            showError 1 "Der Pfad zeigt nicht auf ein gültiges Installationspaket."
        fi

        # Das übergebene Paket ist ok. Lade die Konfigurationsdatei des Paketes und
        # berechnet die Ziel-Pfade für die Installation.
        loadConfigFile
    fi

    # Aktionen, die als letzten Parameter einen Ausgabepfad erwarten
    if [[ "$ACTION" =~ ^(create|pack)$ ]]; then
        OUTPUT="${!#}"
        set -- "${@:1:$(($#-1))}"  # letzten Parameter entfernen
    fi


    # Optionen auslesen
    for arg in "$@"; do
        case "$arg" in
            # Aktionen dürfen an dieser Stelle nicht mehr in der Parameterliste vorkommen,
            # die haben wir eingangs bereits ermittelt
            create|\
            help|-p|--help|\
            info|\
            install|\
            list|ls|\
            pack|\
            remove|\
            version|-V)
                showSyntaxAndExit "Es wurde bereits eine Aktion definiert: $ACTION" ;;
            # Optionen
            --compressed|-c)
                assertAction compressed pack
                assertIsFalse "compressed" "$OPT_COMPRESSED"
                OPT_COMPRESSED=1 ;;
            --copyright=*)
                assertAction copyright create
                assertIsEmpty "copyright" "$PROJECT_COPYRIGHT"
                PROJECT_COPYRIGHT="${arg#*=}" ;;
            --creator=*)
                assertAction creator create
                assertIsEmpty "creator" "$PROJECT_CREATOR"
                PROJECT_CREATOR="${arg#*=}" ;;
            --description=*)
                assertAction description create
                assertIsEmpty "description" "$PROJECT_DESCRIPTION"
                PROJECT_DESCRIPTION="${arg#*=}" ;;
            --dry-run|-d)
                # für alle Aktionen erlaubt!
                assertIsFalse "dry run" $OPT_DRYRUN
                OPT_DRYRUN=1 ;;
            --quiet|-q)
                # für alle Aktionen erlaubt!
                assertIsFalse "quiet" $OPT_QUIET
                OPT_QUIET=1 ;;
            --global|-g)
                assertAction scope install remove
                assertIsEmpty "scope" "$OPT_SCOPE"
                OPT_SCOPE="global" ;;
            --local|-l)
                assertAction scope install remove
                assertIsEmpty "scope" "$OPT_SCOPE"
                OPT_SCOPE="local" ;;
            --name=*)
                assertAction name create
                PROJECT_NAME="${arg#*=}" ;;
            --url=*)
                assertAction url create
                assertIsEmpty "url" "$PROJECT_URL"
                PROJECT_URL="${arg#*=}" ;;
            --use-hooks)
                assertAction "use hooks" install pack remove
                assertIsFalse "use hooks" $OPT_USEHOOKS
                OPT_USEHOOKS=1 ;;
            --verbose|-v)
                assertAction verbose info
                assertIsFalse "verbose" $OPT_VERBOSE
                OPT_VERBOSE=1 ;;
            --version=*)
                assertAction version create
                assertIsEmpty "projektversion" "$PROJECT_VERSION"
                PROJECT_VERSION="${arg#*=}" ;;
            # Alle anderen: Syntax anzeigen und abbrechen
            *)  showSyntaxAndExit "Unbekanntes Argument: $arg" ;;
        esac
    done


    # Auf Vollständigkeit prüfen
    if [[ "$ACTION" =~ ^(install|remove)$ && -z "$OPT_SCOPE" ]]; then
        showSyntaxError "Es wurde kein Zielbereich angegeben."
    fi
}




## ========================================================================================
## Dispatcher-Methoden
## ========================================================================================


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Ein leeres Installationspaket erstellen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
cdeployCreate() {
    # Zusammenfassung der Aufgabe anzeigen
    showTitle
    showMsg "Erzeuge leeres Installationspaket in" \
            "$(absPath "$OUTPUT")" \
            ""

    # Ausgabe prüfen
    if [[ -e "$OUTPUT" ]]; then
        showError 1 "Es gibt bereits ein Objekt mit diesem Namen."
    fi

    # Verzeichnisstruktur anlegen
    mkdir -p "$OUTPUT"/{bin,lib,etc,man,files} || {
        showError 1 "Das Verzeichnis konnte nicht angelegt werden."
    }

    # Leere Standard-Dateien erstellen
    local out="${OUTPUT}/cdeploy.conf"
    cat > "$out" <<EOF
## ================================================================================
## Config-Datei für das Installationsskript 'cdeploy'.
## Verwenden Sie diese Datei um ihre Installationspakete anzupassen.
## ================================================================================


## ==========
## Projektdaten
## ==========

## Projektname, wird u.a. zur Benennung des Zielordners verwendet.
$(makeConfigLine "PROJECT_NAME" "$PROJECT_NAME")

## Projektversion, wird für die Verwaltung der Installationen benötigt.
$(makeConfigLine "PROJECT_VERSION" "$PROJECT_VERSION")

## Ersteller
$(makeConfigLine "PROJECT_CREATOR" "$PROJECT_CREATOR")

## URL zur Webseite / zum Download
$(makeConfigLine "PROJECT_URL" "$PROJECT_URL")

## Copyright
$(makeConfigLine "PROJECT_COPYRIGHT" "$PROJECT_COPYRIGHT")

## Eine kurze Projektbeschreibung.
$(makeConfigLine "PROJECT_DESCRIPTION" "$PROJECT_DESCRIPTION")


## ==========
## INSTALLATIONS-ZIELE
## ==========

## Intallation für alle Benutzer (Parameter 'global').
#BASE_GLOBAL="/usr/local"

## Installation für den ausführenden Benutzer (Parameter 'local').
#BASE_LOCAL="$HOME/.local"


## ==========
## HOOKS
## Implementieren Sie die nachfolgenden Methoden, um den Installer
## noch weiter an Ihre Bedürfnisse anzupassen.
## ==========

## Wird direkt VOR der Installation eines Paketes ausgeführt.
#hookPreInstall() {
#}

## Wird direkt NACH der Intallation eines Paketes ausgeführt.
#hookPostInstall() {
#}


## Wird direkt VOR dem Erstellen einer Archivdatei ausgeführt.
#hookPrePack() {
#}

## Wird direkt NACH dem Erstellen eineer Archivdatei ausgeführt.
#hookPrePack() {
#}


## Wird direkt VOR dem Entfernen eines Paketes ausgeführt.
#hookPreRemove() {
#}

## Wird direkt NACH dem Entfernen eines Paketes ausgeführt.
#hookPostRemove() {
#}
EOF


    out="${OUTPUT}/files/files.conf"
    cat > "$out" <<'EOF'
## Konfigurationsdatei für freies Kopieren von Dateien mit cdeploy.
## Verzeichnisse können mit dieser Funktion nicht kopiert werden.
##
## Definieren Sie in jeder Zeile einen Kopiervorgang, Leerzeilen und
## Kommentare ('#') werden ignoriert.
## Format: <source_file_name> <target_path>
##
## Siehe 'cdeploy help' für mehr Informationen.

# Beispiele:
# foo.txt ~/Dokumente
# bar.txt ~/Dokumente/
# digest ~/Dokumente/foobar.txt
EOF

    showMsg "Das Paket wurde erfolgreich erstellt."
}


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Installiert ein Paket
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
cdeployInstall() {
    # Zielverzeichnisse für die Installation ermitteln
    getInstallerTargets

    # Titel und Beschreibung der Aktion ausgeben
    showTitle

    local scope_str;  [[ "$OPT_SCOPE" == "global" ]] \
                        && scope_str="Globale" || scope_str="Lokale"
    showMsg "${scope_str} Installation von Paket '$(getProjectInfo "")'" \
            "aus Quelle $(absPath "$PACKAGE_INPUT")" \
            "" \
            ""

    # Warnung bei Verwendung von Hooks; Zugriffsrechte prüfen, ggf. Kennwort abfragen
    usesInstallHooks && showHookWarning
    checkPermissions

    SHOW_SYNOPSIS=1


    ##### AB HIER WERDEN WIRKLICH ÄNDERUNGEN VORGENOMMEN #####


    # Hook vor der Installation ausführen
    if isOverridden hookPreInstall; then
        showMsg "Pre-Install Hook ausführen"
        hookPreInstall
        showMsg ""
    fi


    # Wenn eine lokale Installation stattfindet, sicherstellen, dass
    # die lokalen Pfade ~/.local/bin in $PATH und ~/.local/share/man
    # in $MANPATH vorhanden sind
    if [[ "$OPT_SCOPE" == "local" ]]; then
        ensureLocalPath PATH "$HOME/.local/bin"
        ensureLocalPath MANPATH "$HOME/.local/share/man"
    fi

    # Verzeichnis ./bin kopieren
    src="${PACKAGE}/bin"
    if [ -d "$src" ] && [ "$(ls -A "$src")" ]; then
        showMsg "Kopiere Programme..."
        copyFiles "bin" "$src" "$TARGET_BIN"
        # Anstatt die PATH-Variable anzupassen legen wir Symlinks in
        # ~/.local/bin bzw. /usr/local/bin an – abhängig vom OPT_SCOPE.
        # Diese beiden Pfade sind normalerweise immer in PATH enthalten.
        showMsg "  => Erstelle Symlinks..."
        makeSymlinks "$TARGET_BIN" "$TARGET_SYM"
        showMsg ""
    fi

    # Verzeichnis ./lib kopieren
    src="${PACKAGE}/lib"
    if [ -d "$src" ] && [ "$(ls -A "$src")" ]; then
        showMsg "Kopiere Bibliotheken..."
        copyFiles "lib" "$src" "$TARGET_LIB"
        showMsg ""
    fi

    # Verzeichnis ./etc kopieren
    src="${PACKAGE}/etc"
    if [ -d "$src" ] && [ "$(ls -A "$src")" ]; then
        showMsg "Kopiere Konfigurationsdateien..."
        copyFiles "etc" "$src" "$TARGET_ETC"
        showMsg ""
    fi

    # Man-Pages installieren
    src="${PACKAGE}/man"
    if [ -d "$src" ] && [ "$(ls -A "$src")" ]; then
        showMsg "Installiere Man-Pages..."
        installManpages "$src"
        showMsg ""
    fi

    # Freies Kopieren von Dateien
    src="${PACKAGE}/files"
    if [ -d "$src" ] && [ "$(ls -A "$src")" ]; then
        showMsg "Kopiere Dateien..."
        freeCopy "${src}/files.conf" "$src"
        showMsg ""
    fi

    # Hook nach der Installation ausführen
    if isOverridden hookPostInstall; then
        showMsg "" "Post-Install Hook ausführen"
        hookPostInstall
    fi


    showMsg "" "Installation abgeschlossen."
    case $COUNT_CPY in
        0)  showMsg "Es wurden keine Dateien kopiert"  ;;
        1)  showMsg "Es wurde 1 Datei kopiert." ;;
        *)  showMsg "Es wurden ${COUNT_CPY} Dateien kopiert." ;;
    esac
}


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Alle installierten Pakete – getrennt nach lokal/global – auflisten
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
cdeployList() {
    local list

    # Ausgabe für Anzeige mit Pager (less/more) im Terminalfenster
    if isFalse "$OPT_QUIET"; then
        OUTPUT_FORMATTED=1
        USE_PAGER=1
        list="$(makePackageList)"
        echo "$list" | usePager
    fi

    # Ausgabe für Umleitung in Datei
    if [ ! -t 1 ]; then
        OUTPUT_FORMATTED=0
        USE_PAGER=0
        list="$(makePackageList)"
        echo "$list"
    fi
}


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Erstellt eine .cdp-Archivdatei aus einem Installationsverzeichnis
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
cdeployPack() {
    # Zusammenfassung der Aufgabe anzeigen
    showTitle

    local project_info;  project_info="$(getProjectInfo)"
    if [[ "$OPT_COMPRESSED" -eq 1 ]]; then
        showMsg "Erstelle komprimiertes Installationsarchiv für Paket ${project_info}." ""
    else
        showMsg "Erstelle Installationsarchiv für Paket ${project_info}." ""
    fi

    # Archiv-Extension zum Pfad hinzufügen, wenn nötig;
    local filename="${OUTPUT%"$_PACK_EXT"}$_PACK_EXT"
    filename="$(absPath "$filename")"

    # Pfade ausgeben
    showMsg "Quelle..: $(absPath "$PACKAGE_INPUT")" \
            "Ziel....: $(absPath "$filename")" \
            "" \
            ""

    # Warnung ausgeben, falls das Paket Hooks verwendet
    usesPackHooks && showHookWarning

    # Zielpfad prüfen
    if [[ -z "$OUTPUT" ]]; then
        showMsg "Es wurde kein Zielpfad angegeben."
    elif [[ -e "$filename" ]]; then
        if [[ -d "$filename" ]]; then
            showError 1 "Es gibt bereits ein Verzeichnis mit diesem Namen." \
                        "Verzeichnisse können nicht überschrieben werden."
        fi
    fi

    # Variablen prüfen
    for var in PROJECT_NAME OUTPUT; do
        validateVar "$var"
    done

    # Hook vor dem Verpacken ausführen
    if isOverridden hookPrePack; then
        showMsg "Pre-Pack Hook ausführen"
        hookPrePack
        showMsg ""
    fi

    # Installationspaket verpacken
    if [[ "$OPT_COMPRESSED" -eq 1 ]]; then
        # gzip-komprimiert
        tar -czf "$filename" -C "$PACKAGE" . || \
            showError 1 \
                "Fehler beim Erstellen des komprimierten Installationspaketes." \
                "$OUTPUT"
    else
        # schnell, unkomprimiert
        tar -cf "$filename" -C "$PACKAGE" . || \
            showError 1 \
                "Fehler beim Erstellen des Installationspaketes." \
                "$OUTPUT"
    fi

    # Hook nach dem Verpacken ausführen
    if isOverridden hookPostPack; then
        showMsg "" "Post-Pack Hook ausführen"
        hookPostPack
    fi

    showMsg "Das Installationsarchiv wurde erfolgreich erstellt."
}


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Entfernt ein installiertes Paket
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
cdeployRemove() {
    # Titel und Beschreibung der Aktion ausgeben
    showTitle

    local scope_str;  [[ "$OPT_SCOPE" == "global" ]] \
                        && scope_str="Globale" || scope_str="Lokale"
    showMsg "Entfernen der ${scope_str} Installation von Paket" \
            "aus Quelle $(absPath "$PACKAGE_INPUT")" \
            "" \
            ""

    # Zugriffsrechte prüfen, ggf. Kennwort für sudo abfragen
    checkPermissions

    SHOW_SYNOPSIS=1
}


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Hilfeseite (Manpage) anzeigen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
cdeployShowHelpAndExit() {
    showMsg "Hier steht die Hilfeseite."
    exit 0
}


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Paketinformation anzeigen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
cdeployShowPackageInfo() {
    local info

    # Ausgabe für Anzeige mit Pager (less/more) im Terminalfenster
    if isFalse "$OPT_QUIET"; then
        OUTPUT_FORMATTED=1
        USE_PAGER=1
        info="$(makePackageInfo)"
        echo "$info" | usePager
    fi

    # Ausgabe für Umleitung in Datei
    if [ ! -t 1 ]; then
        OUTPUT_FORMATTED=0
        USE_PAGER=0
        info="$(makePackageInfo)"
        echo "$info"
    fi
}


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Zeigt die Versions- und Copyright-Informationen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
cdeployShowVersionAndExit() {
    showMsg "${_SCRIPT_NAME} v${_SCRIPT_VERSION}" \
            "Copyright (c) 2025 Christian Dorn" \
            "Alle Rechte vorbehalten."
    exit 0
}




## ========================================================================================
## Hilfsmethoden
## ========================================================================================


## Relativen Pfad absolut ausgeben
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
absPath() {
    echo "$(cd "$(dirname -- "$1")" && pwd)/$(basename -- "$1")"
}


## Stellt sicher, dass eine Option für die gewählte Aktion $ACTION erlaubt ist.
## Die Option wird als erster Parameter an die Methode übergeben, die
## erlaubte(n) Aktion(en) folgen danach.
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
assertAction() {
    local option="$1"
    shift
    local allowed=("$@")
    for a in "${allowed[@]}"; do
        [[ "$ACTION" == "$a" ]] && return 0
    done

    showError 0 "Die Option '${option}' ist nur in Zusammenhang mit der/den Aktion(en) erlaubt:" \
                "    ${allowed[*]}" \
                "Die gewählte Aktion ist aber '$ACTION'."
    echo
    showSyntaxAndExit
}


## Prüfen ob eine Variable bereits einen Wert enthält
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
assertIsEmpty() {
    local parname="$1"
    local value="$2"

    if [[ -n "$value" ]]; then
        showError 0 "Der Parameter '$parname' wurde bereits übergeben." ""
        showSyntaxAndExit
    fi
}


## Prüfen ob die übergebene Variable einen Wert ungleich 1 hat (false)
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
assertIsFalse() {
    local parname="$1"
    local value="$2"

    if [[ "$value" -eq 1 ]]; then
        showError 0 "Der Parameter ''$parname' wurde bereits übergeben." ""
        showSyntaxAndExit
    fi
}


## Prüfen ob ein Verzeichnis die Mindestanforderungen für ein
## Installationspaket erfüllt
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
checkPackage() {
    local package="$PACKAGE"
    local package_input="$PACKAGE_INPUT"


    if [[ ! -e "$package" ]]; then
        showError 1 "Das Paket wurde nicht gefunden:" \
                    "$(absPath "$package_input")"
    elif [[ ! -d "$package" ]]; then
        showError 1 "Das ist kein Verzeichnis:" \
                    "$(absPath "$package_input")"
    fi

    local src=""

    # a) cdeploy.conf vorhanden?
    src="$package/cdeploy.conf"
    [[ -f "$src" ]] && return 0

    # b) nicht leeres ./bin?
    src="$package/bin"
    [[ -d "$src" && $(find "$src" -maxdepth 1 -type f | wc -l) -gt 0 ]] && return 0

    # c) nicht leeres ./lib?
    src="$package/lib"
    [[ -d "$src" && $(find "$src" -maxdepth 1 -type f | wc -l) -gt 0 ]] && return 0

    # d) nicht leeres ./etc?
    src="$package/etc"
    [[ -d "$src" && $(find "$src" -maxdepth 1 -type f | wc -l) -gt 0 ]] && return 0

    # e) nicht leeres ./man?
    src="$package/man"
    [[ -d "$src" && $(find "$src" -maxdepth 1 -type f | wc -l) -gt 0 ]] && return 0

    # f) ./files mit files.conf und mindestens einer weiteren Datei?
    src="$package/files"
    if [[ -d "$src" && -f "$src/files.conf" ]]; then
        local num_files;  num_files=$(find "$src" -maxdepth 1 -type f | wc -l)
        (( num_files > 1 )) && return 0
    fi

    # An dieser Stelle haben wir sichergestellt, dass das Verzeichnis nicht den
    # Mindestanforderungen für ein Intallationspaket erfüllt
    showError 1 "Das ist kein Installationspaket:" \
                "$(absPath "$package")" \
                "Siehe 'cdeploy help' für mehr Informationen."
    return $?
}


## Zugriffsrechte (Schreibrechte) für übergebenes Objekt prüfen; wenn nötig, sudo-Kennwort
## abfragen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
checkPermissions() {
    # Wenn die Installation global erfolgt, prüfen wir zuerst die Ordner ./bin, ./etc,
    # ./lib und ./man. Wenn in einem dieser Verzeichnisse Dateien sind, Kennwort abfragen
    # und Prüfung beenden.
    if [[ $OPT_SCOPE == "global" ]]; then
        for d in "$TARGET_BIN" "$TARGET_LIB" "$TARGET_ETC" "$TARGET_MAN"; do
            if ! dirIsEmpty "$d"; then
                sudoLogin
                return 0
            fi
        done
    fi

    # Wenn in der ersten Prüfung kein sudo-Kennwort notwendig war, müssen jetzt die
    # Einträge in der Datei 'files.conf' geprüft werden. Sobald eines der Verzeichnisse
    # sudo benötigt, Kennwort abfragen und Prüfung beenden.
    if [[ $USE_SUDO == "" ]]; then
        local files_conf="${PACKAGE}/files.conf"

        # Wenn files.conf nicht existiert → kein sudo nötig
        [[ -f "$files_conf" ]] || return 0

        # 2.2 Alle Zielpfade auslesen
        while IFS= read -r line; do
            # Leerzeilen und Kommentare überspringen
            [[ -z "$line" || "$line" =~ ^# ]] && continue

            # Quelle und Ziel trennen (z. B. "foo.txt   /usr/bin")
            local src dest
            read -r src dest <<<"$line"

            # Wenn kein Ziel angegeben → überspringen
            [[ -z "$dest" ]] && continue

            # Prüfen, ob Zielverzeichnis Schreibrechte erfordert
            local target_dir
            target_dir=$(dirname "$dest")

            if [[ ! -w "$target_dir" ]]; then
                sudoLogin
                return 0
            fi
        done < "$files_conf"
    fi
}


## Datei(en) in Verzeichnis $2 nach $3 kopieren
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
copyFiles() {
    local category="$1"
    local src_dir="$2"
    local dest_dir="$3"

    if [ -d "$src_dir" ]; then
        shopt -s nullglob
        safeRun mkdir -p "$dest_dir"

        for f in "$src_dir"/*; do
            [ -f "$f" ] || continue
            if safeRun cp -u "$f" "$dest_dir/"; then
                safeRun chmod 755 "$dest_dir/$(basename "$f")" \
                    "MSG:  -> $dest_dir/$(basename "$f")"
                manifestAppend "$dest_dir/$(basename "$f")" "$category"
                ((COUNT_CPY+=1))
            fi
        done
        shopt -u nullglob
    fi
}


## Prüfen ob ein Verzeichnis leer ist
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
dirIsEmpty() {
    local path="$1"

    # Wenn Pfad nicht existiert -> prüfe Elternverzeichnis
    if [[ ! -e "$path" ]]; then
        path=$(dirname "$path")
    fi

    # Wenn keine Directory -> false
    if [[ ! -d "$path" ]]; then
        return 1
    fi

    # Wenn Verzeichnis nicht leer -> false
    if [[ $(find "$path" -mindepth 1 -maxdepth 1 2>/dev/null | wc -l) -gt 0 ]]; then
        return 1
    fi

    # Leeres Verzeichnis -> true
    return 0
}


## Lädt die angegebene Datei, wenn der Quellpfad eine URL ist. Liefert
## den Pfad zur heruntergeladenen Datei oder den orignalen Quellpfad,
## wenn dieser keine URL darstellt.
## ---------------------------------------------------------------------
downloadIfURL() {
    local pack_url="$1"

    if [[ "$pack_url" =~ ^(https?|ftp|file):// ]]; then
        showTitle

        # Wir erwarten immer ein cdeploy-Archiv
        if [[ ! "$pack_url" =~ ${_PACK_EXT_RE}$ ]]; then
           showError 1 "Die angegebene Quelle ist kein ${_PACK_EXT}-Archiv."
           return $?
        fi
        showMsg "Lade Installationspaket von URL" \
                "${pack_url}..." \
                ""

        # temporäre Datei oder Verzeichnis
        local tmpfile;  tmpfile=$(mktemp "/tmp/cdeploy_pkg.XXXXXX${_PACK_EXT}") || \
                showError 1 "Temporäre Datei konnte nicht angelegt werden."; return $?
        safeRun curl -fsSL "$pack_url" -o "$tmpfile" || \
                showError 1 "Download fehlgeschlagen."; return $?
        TMP_OBJECTS+=("$tmpfile")

        # Pfad zur temporären Datei zurückgeben
        pack_url="$tmpfile"
    fi

    # Pfad prüfen und zurückgeben
    printf '%s' "$pack_url"
    return 0
}


## Sicherstellen, dass der übergebene Pfad existiert und in der Umgebungsvariablen
## vorhanden ist. Die Methode akzeptiert keine Pfade, die Doppelpunkte (:) enthalten,
## da Doppelpunkte in PATH und MANPATH eine besondere Bedeutung als Trennzeichen
## haben. Außerdem wird sichergestellt, dass MANPATH immer mindestens den Standardpfad
## für Man-Pages enthält.
##
## Die Pfadvariablen werden erweitert, indem der neue Pfad ANGEHÄNGT wird, nicht, wie viele
## Programme es machen, vorangestellt. Die Pfade in den Umgebungsvariablen werden von vorne
## nach hinten durchsucht, und die erste gefundene Datei wird verwendet. Würde $target an
## den Anfang gestellt, könnten – unabsichtlich oder absichtlich – Systemprogramme oder
## Dateien verdeckt werden.
##
## Die Erweiterungen von PATH und MANPATH werden in ~/.profile eingetragen, da diese
## von (den meisten) Shells ausgewertet wird.
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
ensureLocalPath() {
    local varname="$1"
    local target="$2"
    local profile="$HOME/.profile"

    # Doppelpunkte sind in PATH-ähnlichen Variablen verboten. Wenn das Ziel Doppelpunkte
    # enthält, wird das Skript mit einer Fehlermdelung abgebrochen.
    # Wenn der Pfad ok ist, wird er angelegt, falls er noch nicht existiert.
    [[ "$target" == *:* ]] && showError 1 "Pfade mit Doppelpunkt (':') werden nicht unterstützt."
    [ -d "$target" ] || safeRun mkdir -p "$target"

    # Aktuellen Wert der Umgebungsvariablen ermitteln, falls vorhanden
    local current_value=""
    if [[ -n ${!varname-} ]]; then
        current_value="${!varname}"
    fi

    # Falls MANPATH leer ist, den System-Standard verwenden. Dadurch kann MANPATH niemals
    # leer sein. Das ist wichtig, weil 'man' keinen Fallback besitzt, und bei leerem
    # MANPATH somit überhaupt keine Man-Pages mehr gefunden würden.
    if [[ "$varname" == "MANPATH" && -z "$current_value" ]]; then
        current_value=$(man --path 2>/dev/null)
    fi

    # Wenn $target bereits in der Umgebungsvariablen vorhanden ist, kann die Methode an
    # dieser Stelle beendet werden.
    case ":$current_value:" in
        *":$target:"* | *":$target" | "$target:"* | "$target") return 0 ;;
    esac

    # Neue Pfadeinstellung in der aktiven Shell aktivieren
    [[ -n "$current_value" ]] && current_value="$current_value:$target" || current_value="$target"
    eval "export $varname=\"\$$current_value:$target\""

    # Den erweiterten Pfad in ~/.profile eintragen, wenn er dort noch nicht vorhanden ist.
    # Der Eintrag wird eindeutig markiert.
    if [ "$OPT_DRYRUN" -eq 0 ] && \
        ! grep -Eq "^export[[:space:]]+$varname=.*(^|:)$target(:|$)" "$profile" 2>/dev/null; then
        # Start der Änderung in ~/.profile markieren; das Ende wird beim Beenden des
        # Skriptes geschrieben.
        if isFalse "$ENV_PATH_SET"; then
            {
                echo ""
                echo "# >>> cdeploy initialize >>>"
                echo "# Setting path(s) for cdeploy"
                ENV_PATH_SET=1
            } >> "$profile"
        fi

        # Die Pfadanpassung für PATH und MANPATH muss unterschiedlich sein
        # shellcheck disable=SC2016
        case "$varname" in
            PATH)
                echo "export $varname=\"\$$varname:$target\"" >> "$profile" ;;
            MANPATH)
# Zur Erinnerung: muss linksbündig stehen, weil Here-Doc
cat <<EOF >> ~/.profile
if [[ -z "\$MANPATH" ]]; then
    MANPATH="\$(man --path 2>/dev/null || echo \"$TARGET_MAN\")"
fi
export MANPATH="\$MANPATH:$TARGET_MAN"
EOF
        esac

        eval "export $varname=\"\$$varname:$target\""

        # Rückmeldung an den Benutzer
        case $- in
            *i*)  # shellcheck disable=SC1090
                  . "$profile" && showMsg "  -> \$$varname wurde aktualisiert." ;;
            *)    showMsg "  -> \$$varname wurde angepasst. Bitte das Terminal neu starten." "" ;;
        esac
    fi
}


## Installationspaket für (De-)Installation in ein temporäres
## Verzeichnis entpacken
## ---------------------------------------------------------------------
extractPackage() {
    local archive="$1"
    if [[ "$archive" == "" || "$archive" != *"$_PACK_EXT" ]]; then
        printf '%s' "$archive"
        return 0
    fi

    local tmpdir;  tmpdir=$(mktemp -d) || {
        showError 1 "Temporäres Verzeichnis konnte nicht angelegt werden."; return $?
    }

    # temporäres Objekt für das spätere Aufräumen merken
    TMP_OBJECTS+=("$tmpdir")

    tar -xf "$archive" -C "$tmpdir" || {
        showError 1 "Archiv konnte nicht extrahiert werden."; return $?
    }

    printf '%s' "$tmpdir"  # $tmpdir zurückgeben
    return 0
}


## Daten an eine Datei anhängen. Die Datei wird bei Bedarf automatisch
## erzeugt, und falls nötig wird eine sudo-Berechtigung abgefragt und
## angewandt.
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
fileAppend() {
    local datei="$1"
    shift || return 1

    local status=0

    # +e erlaubt Fehlerhandling ohne Skriptabbruch
    set +e
    # Alle Zeilen gesammelt anhängen; anstatt 'printf "%b"' werden die Tabs gezielt per
    # 'sed' expandiert. Das minimiert die Gefahr durch eingeschleuste Escape-Sequenzen,
    # die von 'printf "%b"' interpretiert würden.
    #printf "%s\n" "$@" | $USE_SUDO tee -a "$datei" >/dev/null
    for arg in "$@"; do
        printf "%s\n" "$(printf "%s" "$arg" | sed 's/\\t/\t/g')" | \
                $USE_SUDO tee -a "$datei" >/dev/null
    done
    status=$?
    set -e

    if (( status != 0 )); then
        showError 1 "Manifest kann nicht geschrieben werden: $datei"
    fi

    return $status
}


## Aufräumen beim Beenden oder Abbrechen des Skriptes
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
finalCleanup() {
    # Zuerst alle Traps entfernen, um Rekursionen zu vermeiden
    trap - EXIT INT TERM HUP

    # Offenen Eintrag in ~/.profile abschließen
    if isFalse "$OPT_DRYRUN" && isTrue "$ENV_PATH_SET"; then
        echo "# <<< cdeploy initialize <<<" >> "$HOME/.profile"
    fi

    # Temporäre Dateien/Verzeichnisse entfernen
    for p in "${TEMP_OBJECTS[@]}"; do
        [[ -e $p ]] && safeRun rm -rf -- "$p"
    done

    # Verwendung von sudo deaktivieren
    USE_SUDO=""
}


## Freies Kopieren von Dateien und Verzeichnissen im ./files Verzeichnis
## des Installationspaketes. Das Ziel für diese Objekte muss in der
## Datei ./files/files.conf definiert werden.
## Beispiel:
##     foo.txt ~/Dokumente
##     bar.txt ~/Dokumente/
##     summary ~/Dokumente/digest.txt
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
freeCopy() {
    local def_file="$1"  # Konfigurationsdatei für das Kopieren
    local src_base="$2"  # Quellverzeichnis im Paket
    local output status
    local src dest
    local src_path dest_path

    [ -f "$def_file" ] || \
        { showWarning "Keine Konfigurationsdatei für das Kopieren gefunden."; return; }

    set +e
    while IFS=$'\t ' read -r src dest || [ -n "$src" ]; do
        # Kommentare und leere Zeilen überspringen
        [[ -z "$src" || "$src" =~ ^# ]] && continue

        # Quell- und Zielpfad einstellen
        src_path="$src_base/$src"
        dest_path="$dest"

        if [ ! -e "$src_path" ]; then
            showWarning "Die Quelldatei existiert nicht." \
                        "$src_path"
            continue
        elif [ -d "$src_path" ]; then
            showWarning "Es werden keine Verzeichnisse kopiert!" \
                        "Mehr Informationen finden Sie hier: 'cdeploy --help'." \
                        "$src_path"
            continue
        fi

        # Zielverzeichnis erstellen; wenn eine Tile am Anfang des Zielpfades steht,
        # ersetze sie durch den absoluten Pfad zum Benutzerverzeichnis
        [[ "$dest_path" == ~* ]] && dest_path="${dest_path/#\~/$HOME}"
        if [ ! -e "$dest_path" ]; then
            if [[ "$dest_path" == */ ]]; then
                safeRun mkdir -p "$dest_path"
            else
                safeRun mkdir -p "$(dirname "$dest_path")"
            fi
        fi

        # Datei aus dem Paket in das Ziel kopieren
        if [ -d "$dest_path" ] || [[ "$dest_path" == */ ]]; then
            # $dest_path ist ein Verzeichnis
            if safeRun cp -uT "$src_path" "$dest_path" \
                 "MSG:  -> V $src -> $dest_path"; then
                manifestAppend "$dest_path" "files"
                ((COUNT_CPY+=1))
            fi
        else
            # $dest_path ist eine Datei
            if safeRun cp -u "$src_path" "$dest_path" \
                 "MSG:  -> D $src -> $dest_path"; then
                manifestAppend "$dest_path" "files"
                ((COUNT_CPY+=1))
            fi
        fi
    done < "$def_file"
    set -e
}


## Liefere den sha256 Hash für eine Datei/ein Verzeichnis
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
getFileHash() {
    local filepath="$1"

    # Datei/Verzeichnis nicht gefunden oder nicht übergeben
    #if [ ! -f "$filepath" ]; then
    if [ ! -f "$filepath" ] && [ ! -d "$filepath" ]; then
        echo "n/a"
        return 1
    fi

    # sha256-Hash berechnen
    if command -v sha256sum >/dev/null 2>&1; then
        if [ -d "$filepath" ]; then
            ( cd "$filepath" && find . -type f -exec sha256sum {} + | sort | \
                    sha256sum | awk '{print $1}' )
        else
            sha256sum "$filepath" | awk '{print $1}'
        fi
        return 0
    elif command -v shasum >/dev/null 2>&1; then
        if [ -d "$filepath" ]; then
            ( cd "$filepath" && find . -type f -exec shasum -a 256 {} + | sort | \
                    shasum -a 256 | awk '{print $1}' )
            else
                shasum -a 256 "$filepath" | awk '{print $1}'
            fi
        return 0
    fi

    # kein SHA-Tool verfügbar
    echo "n/a"
    return 2
}


## Zielverzeichnisse für (De-)Installation ermitteln und an die
## globalen Variablen übertragen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
getInstallerTargets() {
    # Zielverzeichnisse ermitteln
    case "$OPT_SCOPE" in
        global)
            TARGET_BASE="${BASE_GLOBAL}/${PROJECT_NAME}"
            TARGET_MAN="/usr/share/man"
            TARGET_SYM="/usr/local/bin"
            ;;
        local)
            TARGET_BASE="${BASE_LOCAL}/${PROJECT_NAME}"
            TARGET_MAN="$HOME/.local/share/man"
            TARGET_SYM="$HOME/.local/bin"
            ;;
        *)
            showError 1 "Unbekannter Zielbereich, oder Zielbereich nicht definiert: '$OPT_SCOPE'" ;;
    esac

    TARGET_BIN="${TARGET_BASE}/bin"
    TARGET_LIB="${TARGET_BASE}/lib"
    TARGET_ETC="${TARGET_BASE}/etc"
    TARGET_MANIFEST="$(getManifestDir $OPT_SCOPE)"

    for var in PROJECT_NAME TARGET_BASE TARGET_BIN TARGET_ETC TARGET_LIB TARGET_MAN \
                TARGET_MANIFEST TARGET_SYM; do
        validateVar "$var"
    done
}


## Liefert den Pfad zum lokalen/globalen Manifest-Verzeichnis
## ---------------------------------------------------------------------
getManifestDir() {
    case "$1" in
    global) echo "/usr/local/share/${_SCRIPT_NAME}/manifests" ;;    # Pfad zurückgeben
    local)  echo "$HOME/.local/share/${_SCRIPT_NAME}/manifests" ;;  # Pfad zurückgeben
    *)      showError 1 "Illegaler Zielbereich: $1" ;;
    esac
}


## Liefert die Projektinformation (Name + Version) als String
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
getProjectInfo() {
    local divider="${1:- }"

    if isEmpty "$PROJECT_NAME"; then
        PROJECT_NAME="tools"
    fi

    if isEmpty "$PROJECT_VERSION"; then
        echo "$PROJECT_NAME"
    else
        echo "${PROJECT_NAME}${divider}${PROJECT_VERSION}"
    fi
}


## Liefert einen String zur Anzeige des Zielbereichs (Scope)
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
getScopeStr() {
    if [[ "$OPT_SCOPE" == "global" ]]; then
        echo "global"
    else
        echo "lokal"
    fi
}


## Installieren der Man-Pages aus dem Installationspaket
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
installManpages() {
    local src_dir="$1"
    local dest_dir="$TARGET_MAN"
    local target_dir

    if [ -d "$src_dir" ]; then
        # Kopiere die Dateien aus dem Paket an den Zielort; passe die Zugriffsrechte
        # an (644); wandle die kopierte Man-Page in eine .gz-Datei, wenn möglich;
        # trage die fertige Datei ins Manifest ein
        for manfile in "$src_dir"/*.[1-9]; do
            [ -f "$manfile" ] || continue
            section="${manfile##*.}"
            target_dir="$dest_dir/man$section"
            safeRun mkdir -p "$target_dir"
            if safeRun cp -u "$manfile" "$target_dir/" \
                 "MSG:  -> $target_dir/$(basename "$manfile").gz"; then
                safeRun chmod 644 "$target_dir/$(basename "$manfile")"
                ((COUNT_CPY+=1))
                if safeRun gzip -f "$target_dir/$(basename "$manfile")"; then
                    manifestAppend "$target_dir/$(basename "$manfile".gz)" "man"
                else
                    manifestAppend "$target_dir/$(basename "$manfile"*)" "man"
                fi
            fi
        done

        # Man-Datenbank aktualisieren
        if [ "$OPT_SCOPE" = "global" ]; then
            showMsg "  => Aktualisiere globale Man-Datenbank..."
            if ! $USE_SUDO mandb -q; then
                showWarning "Die globale Man-Datenbank konnte nicht aktualisiert werden."
            fi
        else
            showMsg "  => Aktualisiere lokale Man-Datenbank..."
            if ! mandb -q -u; then
                showWarning "Die lokale Man-Datenbank konnte nicht aktualisiert werden."
            fi
        fi
    fi
}


## Prüfen ob eine Variable leer ist
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
isEmpty() {
    if [ -z "$1" ] || [ "$1" == "" ]; then
        return 0
    fi
    return 1
}


## Behandelt die übergebene Variable als Boolean und gibt 0 zurück, wenn diese leer oder
## '0' ist, ansonsten 1
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
isFalse() {
    case "$1" in
        ""|0) return 0 ;;
        *)    return 1 ;;
    esac
}


## Prüfen ob ein Hook überschrieben wurde (also tatsächlich Code enthält)
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
isOverridden() {
    local name="$1"
    local def

    # declare -f liefert die komplette Funktionsdefinition (oder nichts)
    if ! def=$(declare -f "$name" 2>/dev/null); then
        return 1  # Funktion existiert nicht -> nicht überschrieben
    fi
    # Wenn der Marker in der Definition vorkommt -> Default noch aktiv
    if printf '%s\n' "$def" | grep -q '__DEFAULT_HOOK__'; then
        return 1   # nicht überschrieben
    else
        return 0   # überschrieben
    fi
}


## Behandelt die übergebene Variable als Boolean; kehrt den Rückgabewert von 'isFalse' um.
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
isTrue() {
    isFalse "$1"; return $((1 - $?))
}


## Konfigurationsdatei einbinden
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
loadConfigFile() {
    local config_file="${PACKAGE}/cdeploy.conf"

    if [[ -f "$config_file" ]]; then
        if ! bash -n "$config_file" 2>/dev/null; then
            showError 1 "Die Konfigurationsdatei hat ein ungültiges Format." "$config_file"
        fi
        # shellcheck disable=SC1090
        source "$config_file"
    fi
}


## Erstellt einen Key-Value-Eintrag für eine Konfigurationsdatei.
## Wenn die übergebene Variable leer ist, wird der Eintrag als Kommentar
## angelegt, ansonsten als aktive Zeile.
## ---------------------------------------------------------------------
makeConfigLine() {
    local varname="$1"
    local value="$2"
    if [[ -n "$value" ]]; then
        echo "${varname}=\"${value}\""
    else
        echo "#${varname}=\"\""
    fi
}


## Erstellt die Paketinformationen zur Anzeige im Terminal und/oder Ausgabe in Datei
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
makePackageInfo() {
    local output

    output="$(
        local _lw=80;  readonly _lw

        # Titel und Beschreibung der Aktion ausgeben
        showTitle

        showMsg "Informationen zu Paket aus Quelle" \
                "$(absPath "$PACKAGE_INPUT")" \
                "" \
                ""

        # Prüfen ob das Paket existiert
        if [[ ! -e "$PACKAGE" ]]; then
            showError 1 "Das angegebene Paket wurde nicht gefunden."
            return 0
        fi

        # Hinweis ausgeben, wenn das Paket Hooks definiert
        if usesHooks; then
            showMsg \
                "   ================================================================================" \
                "    DIESES PAKET ENTHÄLT SKRIPTERWEITERUNGEN DES ANBIETERS, DIE DIE FUNKTIONALITÄT" \
                "    VON CDEPLOY ERWEITERN. DIES IST KEIN FEHLER, STELLT ABER EIN POTENTIELLES" \
                "    SICHERHEITSRISIKO DAR, DA SO AUCH SCHADHAFTER CODE AUSGEFÜHRT WERDEN KÖNNTE." \
                "" \
                "    VERWENDEN SIE DAS PAKET DAHER NUR, WENN SIE ES VON EINER VERTRAUENSWÜRDIGEN" \
                "    QUELLE ERHALTEN HABEN!" \
                "   ================================================================================" \
                "" \
                ""
        fi

        # Zur Erinnerung: Der Variablenname 'hash' kollidiert hier mit dem eingebauten Bash
        #                 Befehl gleichen Namens! Daher 'hsh' verwenden.
        local hsh;  hsh="$(getFileHash "$PACKAGE_SOURCE")"
        case $? in
            1) hsh="${hsh} (Paket nicht gefunden)" ;;
            2) hsh="${hsh} (kein SHA-Tool gefunden)" ;;
        esac

        showMsg "Paketinformation" \
            "================" \
            "Name.................: ${PROJECT_NAME:-./.}" \
            "Version..............: ${PROJECT_VERSION:-./.}" \
            "Ersteller............: ${PROJECT_CREATOR:-./.}" \
            "Quelle/URL...........: ${PROJECT_URL:-./.}" \
            "Hash.................: $hsh" \
            "Copyright............: ${PROJECT_COPYRIGHT:-./.}"

        showMsg "" \
            "Installationspfade:" \
            "    Lokal............: ${BASE_LOCAL:-./.}" \
            "    Global...........: ${BASE_GLOBAL:-./.}"

        showMsg "" \
            "Beschreibung:" \
            "${PROJECT_DESCRIPTION:-./.}" | fold -s -w "$_lw"


        # Hier aufhören für die einfache Ausgabe
        if isFalse "$OPT_VERBOSE"; then return 0; fi


        # Erweiterte Ausgabe inkl. aller Dateien
        local total=0

        showMsg "" \
            "" \
            "Dateien im Paket" \
            "================"

        # ./bin, ./lib, ./etc, ./man
        for dir in bin lib etc man; do
            if [[ -d "${PACKAGE}/$dir" ]]; then
                showMsg "./$dir"
                while IFS= read -r f; do
                    showMsg "    $f"
                    ((total+=1))
                done < <(ls -1 "${PACKAGE}/$dir")
                showMsg ""
            fi
        done

        # --- files ---
        local files_dir="${PACKAGE}/files"
        local files_conf="$files_dir/files.conf"

        if [[ -d "$files_dir" && -f "$files_conf" ]]; then
            showMsg "files/  (gruppiert nach Ziel)"

            # Kommentare und Leerzeilen überspringen, sortieren, zählen
            mapfile -t lines < <(grep -Ev '^\s*#|^\s*$' "$files_conf" | sort -k2,2 -k1,1)

            local last_target=""
            local filecount=0

            for line in "${lines[@]}"; do
                src=${line%%[[:space:]]*}
                target=${line#*[[:space:]]}

                # Verzeichnisanteil extrahieren:
                if [[ "$target" == */ ]]; then
                    # endet auf / -> ist ein Verzeichnis
                    target="${target%/}"
                elif [[ "$target" == *"/"* ]]; then
                    # enthält / -> alles vor letztem /
                    src="${target##*/}"
                    target="${target%/*}"
                else
                    # kein / -> aktuelles Verzeichnis
                    target="."
                fi

                if [[ "$target" != "$last_target" ]]; then
                    showMsg "    $target/"
                    last_target=$target
                fi
                showMsg "        $src"
                ((filecount+=1))
            done

            total=$(( total + filecount ))
            showMsg ""
        fi

        showMsg "" "Es befinden sich insgesamt $total Datei(en) im Paket."
        )"


    # Die erstellten Informationen zurückgeben
    echo "$output"
}


## Erstellt die Paketinformationen zur Anzeige im Terminal und/oder Ausgabe in Datei
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
makePackageList() {
    local output

    output="$(
    local local_manifests;  local_manifests=$(getManifestDir local)
    local global_manifests; global_manifests=$(getManifestDir global)
    local counter=0

    # Titel und Beschreibung der Aktion ausgeben
    showTitle

    showMsg "Liste aller mit cdeploy installierten Pakete auf diesem System." \
            "" \
            ""

    showMsg "lokal"
    if [ -d "$local_manifests" ]; then
        for f in "$local_manifests"/*.manifest; do
            [ -e "$f" ] || continue   # wenn kein Manifest existiert
            showMsg "    $(basename "${f%.manifest}")"
            ((counter+=1))
        done
        echo
    else
        showMsg "    (keine)"
        echo
    fi

    showMsg "global"
    if [ -d "$global_manifests" ]; then
        for f in "$global_manifests"/*.manifest; do
            [ -e "$f" ] || continue
            showMsg "    $(basename "${f%.manifest}")"
            ((counter+=1))
        done
    else
        showMsg "    (keine)"
    fi


    case $counter in
        0) showMsg "" "" "Es sind keine Pakete installiert." ;;
        1) showMsg "" "" "Es ist 1 Paket installiert." ;;
        *) showMsg "" "" "Es sind insgesamt $counter Pakete installiert." ;;
    esac
    )"

    # Die erstellten Informationen zurückgeben
    echo "$output"
}


## Symlinks auf alle Objekte in 'dest_dir' erstellen, die auch in
## 'src_dir' vorhanden sind. Damit soll vermieden werden, dass die PATH
## Variable angepasst werden muss, um die kopierten Skripte global
## ausführbar zu machen.
## 'dest_dir' sollte abhängig vom Scope entweder /usr/local/bin oder
## ~/.local/bin sein.
## ---------------------------------------------------------------------
makeSymlinks() {
    local src_dir="$1"
    local dest_dir="$2"
    local dest_file

    if [ -d "$src_dir" ]; then
        safeRun mkdir -p "$dest_dir"
        for f in "$src_dir"/*; do
            [ -f "$f" ] || continue
            dest_file="$dest_dir/$(basename "$f")"
            safeRun ln -sf "$f" "$dest_file" \
                 "MSG:     -> $dest_file -> $f"
            manifestAppend "$dest_file" "link"
        done
    fi
}


## Enitrag zur Manifest-Datei hinzufügen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
manifestAppend() {
    # Bei Testläufen wird kein Manifest geschrieben; abbrechen
    if [ "$OPT_DRYRUN" -ne 0 ]; then return 0; fi


    # Wenn nötig, Header für Manifest-Datei schreiben
    if [[ -z "$MANIFEST_FILE"  ]]; then manifestInit; fi

    # übergebene Dateiinformationen lesen und prüfen
    local filepath="$1"
    local category="$2"

    [ -f "$filepath" ] || return 1

    # SHA256 Hash ermitteln
    local hash;  hash="$(getFileHash "$filepath")"

    # Dateigröße und mtime ermitteln
    local size mtime
    if stat --version >/dev/null 2>&1; then
        # GNU stat (Linux)
        size=$(stat -c%s "$filepath")
        mtime=$(stat -c%Y "$filepath")
    else
        # BSD/macOS stat
        size=$(stat -f%z "$filepath")
        mtime=$(stat -f%m "$filepath")
    fi

    # Zeile ins Manifest schreiben
    fileAppend "$MANIFEST_FILE" "${filepath}\t${hash}\t${mtime}\t${category}\t${size}"
}


## Manifest-Datei anlegen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
manifestInit() {
    # Bei Testläufen wird kein Manifest geschrieben; abbrechen
    if [ "$OPT_DRYRUN" -ne 0 ]; then return 0; fi


    # Bestimmen der Manifestdatei
    safeRun mkdir -p "$TARGET_MANIFEST"

    MANIFEST_FILE="${TARGET_MANIFEST}/$(getProjectInfo -).manifest"
    if [ -f "$MANIFEST_FILE" ]; then
        safeRun rm "$MANIFEST_FILE"
    fi

    # Header schreiben
    local install_date;  install_date=$(date -Iseconds)

    fileAppend "$MANIFEST_FILE" \
        "###" \
        "# ${_SCRIPT_NAME} v${_SCRIPT_VERSION} – Manifest" \
        "# Projekt...........: ${PROJECT_NAME} v${PROJECT_VERSION}" \
        "# Installationsdatum: $install_date" \
        "# Quelle/Paket......: $(absPath "$PACKAGE")" \
        "#" \
        "# Zielpfad\tHash_SHA256\tmtime\tKategorie\tGröße" \
        "###" \
        ""
}


## Skript beenden
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
quit() {
    local return_code="$1"

    # Zusammenfassung zu Fehlern und Warnungen ausgeben
    if isTrue $SHOW_SYNOPSIS; then
        local warn_str
        [[ $COUNT_WRN -eq 1 ]] && warn_str="Warnung" || warn_str="Warnungen"
        showMsg "" "${COUNT_WRN} ${warn_str}, ${COUNT_ERR} Fehler"
    fi

    # Ggf. Hinweis auf Testlauf ausgeben
    if [ "$return_code" -lt 255 ] && isTrue "$OPT_DRYRUN"; then
        showMsg "" \
                "" \
                "     !!! ============================================================== !!!" \
                "     !!!  DAS WAR EIN TESTLAUF. ES WURDEN KEINE ÄNDERUNGEN VORGENOMMEN  !!!" \
                "     !!!                ES WURDEN KEINE DATEIEN KOPIERT                 !!!" \
                "     !!!               ES WURDE KEIN MANIFEST GESCHRIEBEN               !!!" \
                "     !!! ============================================================== !!!" \
                "" \
                ""
    fi

    # Darstellung beenden
    showBottomLine

    # Skript mit übergebenen Returncode abschließen
    exit "$return_code"
}


## Anweisung sicher ausführen; automatisch sudo-Berechtigung verwenden,
## wenn nötig; bei Fehler Meldung ausgeben und Fehlercode zurückgeben
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
safeRun() {
    local args=("$@")
    local msg=""
    local output
    local status=0

    # Optional: Den letzten Parameter als Meldung verwenden, wenn er mit 'MSG:' beginnt.
    #           Anschließend den letzten Parameter entfernen.
    if [[ "${args[-1]}" == MSG:* ]]; then
        msg="${args[-1]#MSG:}"   # entfernt das Präfix
        unset 'args[-1]'         # entfernt letzten Parameter aus dem Befehl
    fi

    # Das letze Argument ist (jetzt) der Zielpfad. Falls er mit einer Tile beginnt, diese
    # durch den absoluten Pfad zum Benutzerverzeichnis ersetzen.
    local target="${args[-1]}"
    [[ "$target" == ~* ]] && target="${target/#\~/$HOME}"

    # Prüfen ob die sudo-Anmeldung noch gültig ist; ein erneutes Login aber nur durchführen,
    # wenn beim Start des Skriptes schon eine Anmeldung erfolgreich war
    if [[ "$USE_SUDO" == "sudo" ]] && ! sudo -n true; then
        showMsg "   Die Administratorrechte sind abgelaufen. Bitte melden Sie sich erneut an."
        sudoLogin
    fi

    # Befehl ausführen; dazu das Abbruchkriterium -e (abbrechen, wenn Returncode ≠ 0)
    # kurzzeitig außer Kraft setzen, damit bei einem Fehler die nachfolgenden Dateien
    # noch verarbeitet werden; für nicht verarbeitete Dateien wird eine Fehlermeldung
    # ausgegeben
    if [ "$OPT_DRYRUN" -eq 0 ]; then
        set +e
        output=$($USE_SUDO "${args[@]}" 2>&1)
        status=$?
        set -e
    fi

    # Fehler ausgeben, falls der Befehl fehlgeschlagen ist, und den Returncode des Befehls
    # zurückgeben.
    if [ "$status" -ne 0 ]; then
        local err_msg="${output##*:}"
        showError 0 "${err_msg#"${err_msg%%[! ]*}"}"
        return $status
    fi

    # Wenn als letzter Parameter eine Meldung übergeben wurde (s.o.), muss diese jetzt
    # ausgegeben werden
    if [[ -n "$msg" ]]; then showMsg "$msg"; fi
    return 0
}


## Gbit eine Abschlusslinie aus, die das Ende der Skriptausgabe markiert
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
showBottomLine() {
    if isTrue "${_BOTTOM_LINE_SHOWN:=0}"; then return; fi
    declare -gr _BOTTOM_LINE_SHOWN=1

    # Ausgabe im Terminalfenster
    if isFalse $OPT_QUIET; then
        {
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo
        } > /dev/tty
    fi

    # Ausgabe für Umleitung in Datei
    if [ ! -t 1 ]; then
        echo "===================================================================================="
    fi
}


## Fehlermeldung ausgeben; Skript beenden, wenn Fehlercode <> 0
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
showError() {
    local err_code="$1"
    shift  # entferne den ersten Parameter (Fehlercode) aus "$@"

    # Fehlercounter anpassen; hat in Sub-Shells keine Auswirkung
    # auf die Haupt-Shell
    ((COUNT_ERR+=1))

    if isFalse $OPT_QUIET; then
        # Alle übrigen Parameter als separate Zeilen ausgeben
        showTitle

        # Ausgabe im Terminal
        local line="$1"
        shift

        case "$line" in
            "!!!! "*)
                printf "%s" "$line" ;;
            *)
                # Ausgabe in Datei/Umleitung
                printf "!!!! %s\n" "$line"
                if [ $# -gt 0 ]; then
                    printf "  !! %s\n" "$@"
                fi ;;
        esac
    fi


    # Skript beenden, wenn wir in der Haupt-Shell sind und der Fehlercode ≠ 0 ist;
    # in jedem anderen Fall einfach den Fehlercode zurückgeben
    if [ "$err_code" -ne 0 ] && [ "${BASH_SUBSHELL:=0}" -eq 0 ]; then
        quit "$err_code"
    else
        return "$err_code"
    fi
}


## Eine Warnmeldung ausgeben, wenn ein Paket Hooks definiert
## ---------------------------------------------------------------------
showHookWarning() {
    if isTrue "$OPT_USEHOOKS"; then
        showMsg "DIE VERWENDUNG VON SKRIPTERWEITERUNGEN (\"HOOKS\") WURDE AKTIVIERT." "" ""
        return 0
    fi

    showMsg \
        "   WARNUNG" \
        "   –––––––" \
        "   DIESES PAKET ENTHÄLT SKRIPTERWEITERUNGEN DES ANBIETERS, DIE DIE FUNKTIONALITÄT" \
        "   VON CDEPLOY ERWEITERN. DIES IST KEIN FEHLER, STELLT ABER EIN POTENTIELLES" \
        "   SICHERHEITSRISIKO DAR, DA SO AUCH SCHADHAFTER CODE AUSGEFÜHRT WERDEN KÖNNTE." \
        "" \
        "   VERWENDEN SIE DAS PAKET DAHER NUR, WENN SIE ES VON EINER VERTRAUENSWÜRDIGEN" \
        "   QUELLE ERHALTEN HABEN!" \
        "" \
        "   Wenn Sie das Paket trotzdem verwenden möchten, tippen Sie \"ja\"." \
        "   Mit jeder anderen Eingabe brechen Sie den Vorgang ab."

    echo -n "   > "; read -r choice
    if [[ "$choice" != "ja" ]]; then
        showMsg "" "   (Vorgang vom Benutzer abgebrochen.)" ""
        quit 2
    fi

    showMsg "" "   (Das Paket wird verwendet.)" "" ""
    return 0
}



## Eine Meldung ausgeben
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
showMsg() {
    if isFalse $OPT_QUIET; then
        printf "%b\n" "$@"
    fi
}


## Titelzeile anzeigen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
showTitle() {
    if isTrue "${_TITLE_SHOWN:=0}"; then return; fi
    declare -gr _TITLE_SHOWN=1

    local info="${_SCRIPT_NAME} Version ${_SCRIPT_VERSION} · Copyright (c) 2025 Christian Dorn · Alle Rechte vorbehalten. "

    if isTrue "$OUTPUT_FORMATTED"; then
        showMsg "" \
                "${_INVERT} ${info} ${_RESET}" \
                ""
    else
        showMsg "" \
                "====================================================================================" \
                "${info}" \
                "====================================================================================" \
                ""
    fi
}


## Warnmeldung ausgeben
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
showWarning() {
    ((COUNT_WRN+=1))

    if isFalse $OPT_QUIET; then
        # Alle Parameter als separate Zeilen ausgeben
        showTitle

        # Ausgabe im Terminal
        local line="$1"
        shift

        printf "???? %s\n" "$line"
        printf "  ?? %s\n" "$@"
    fi
}


## Anzeigen der gültigen Syntax und Abbrechen des Skripts
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
showSyntaxAndExit() {
    showTitle

    # optionale Fehlermeldungen ausgeben
    if [[ $# -gt 0 ]]; then
        showError 0 "$@"
        showMsg ""
    fi

    # Gültige Syntax ausgeben
    showMsg "Syntax: cdeploy help" \
            "        cdeploy create [opt...] <package>" \
            "        cdeploy info [--verbose] [--quiet] <package>" \
            "        cdeploy install --global|--local <package>" \
            "        cdeploy remove --global|--local <package>" \
            "        cdeploy version"

    quit 255
}


## sudo-Login
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
sudoLogin() {
    echo "   Für diese Aktion benötigen Sie Administratorrechte." > /dev/tty
    if [[ ! -t 1 ]]; then
        echo -n "   [sudo Kennwortabfrage]"
    fi

    # Trap, damit bei Strg-C sauber aufgeräumt wird (Kennwort-Variable löschen) und das
    # Skript mit einem Fehlercode (1) zurückkommt.
    local pw
    trap '[[ ! -t 1 ]] && echo > /dev/tty; showMsg "" "" "   (Abbruch durch den Benutzer)" ""; pw=""; unset pw; trap - INT; quit 1' INT

    while true; do
        # Passwort ohne Echo einlesen; bei Strg-C oder EOF liefert read !=0
        if ! read -rsp "   Bitte geben Sie ihr Kennwort ein (Strg-C zum Abbrechen): " pw; then
            if isTrue "$OPT_QUIET"; then echo > /dev/tty; fi
            showMsg "" "" "   (Abbruch durch den Benutzer)" ""
            quit 1
        fi

        # Passwort an sudo übergeben; Ausgaben unterdrücken
        if printf '%s\n' "$pw" | sudo -S -v >/dev/null 2>&1; then
            sleep 0.05
            # Erfolg. Passwort löschen und Funktion mit Erfolg beenden
            pw=""; unset pw; trap - INT
            if isTrue "$OPT_QUIET"; then echo > /dev/tty; fi
            showMsg "" "" ""
            USE_SUDO="sudo"
            return 0
        else
            # Fehler: Passwort löschen, Hinweis ausgeben, Schleife wiederholen
            pw=""; unset pw
            echo "" > /dev/tty
            echo "" > /dev/tty
            echo "   Falsches Kennwort, bitte versuchen Sie es nocheinmal. " > /dev/tty
            # Schleife läuft weiter
        fi
    done

    # Irgendetwas ist schiefgelaufen, an diese Stelle sollten wir nicht kommen!
    showMsg ""
    showError 1 "Ein unbekannter Fehler ist aufgetreten. cdeploy wird beendet."
}


## Ändert das erste Zeichen im übergeben String in einen Großbuchstaben
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
toCapitalized() {
    local text="$1"
    echo "${text^}"
}


## Ändert alle Zeichen im übergebenen Strnig in Kleinbuchstaben
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
toLowercase() {
    local text="$1"
    echo "${text,,}"
}


## Ändert alle Zeichen im übergebenen String in Großbuchstaben
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
toUppercase() {
    local text="$1"
    echo "${text^^}"
}


## Gibt Eingabe durch less, more oder cat aus – je nach Umgebung
## ---------------------------------------------------------------------
usePager() {
    if isTrue "$USE_PAGER"; then
        # interaktiv: Ausgabe an Terminal
        if command -v less >/dev/null 2>&1; then
            less -rXF > /dev/tty
        elif command -v more >/dev/null 2>&1; then
            more > /dev/tty
        else
            cat > /dev/tty
        fi
    else
        # Ausgabe ohne Pager
        cat
    fi
}


## Prüft ob mindestens ein Hook definiert ist
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
usesHooks() {
    usesInstallHooks && return 0
    usesPackHooks && return 0
    usesRemoveHooks && return 0
    return 1
}


## Prüft ob Install-Hooks verwendet werden
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
usesInstallHooks() {
    isOverridden hookPreInstall && return 0
    isOverridden hookPostInstall && return 0
    return 1
}


## Prüft ob Pack-Hooks verwendet werden
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
usesPackHooks() {
    isOverridden hookPrePack && return 0
    isOverridden hookPostPack && return 0
    return 1
}


## Prüft ob Remove-Hooks verwendet werden
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
usesRemoveHooks() {
    isOverridden hookPreRemove && return 0
    isOverridden hookPostRemove && return 0
    return 1
}


## Plausibilitätsprüfung für (Pfad-)Variablen (leer oder ungültige Zeichen)
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
validateVar() {
    local varname="$1"
    local value="${!varname}"
    if [[ -z "$value" ]]; then
        showError 1 "Variable $varname ist leer."
    fi
    if [[ "$value" =~ [^a-zA-Z0-9._/-] ]]; then
        showError 1 "Variable $varname enthält ungültige Zeichen." "$value"
    fi
}




## ========================================================================================
## Hooks definieren (leere Standard-Implementierungen)
## Hooks können in der Datei 'cdeploy.conf' im Installationspaket überschrieben werden und
## erweitern die Funktionalität von cdeploy.
## ========================================================================================
hookPreInstall()   { : __DEFAULT_HOOK__; }
hookPostInstall()  { : __DEFAULT_HOOK__; }
hookPrePack()      { : __DEFAULT_HOOK__; }
hookPostPack()     { : __DEFAULT_HOOK__; }
hookPreRemove()    { : __DEFAULT_HOOK__; }
hookPostRemove()   { : __DEFAULT_HOOK__; }




## ========================================================================================
## Aufruf der main()-Methode
## ========================================================================================
main "$@"
