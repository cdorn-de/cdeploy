#!/usr/bin/env bash


###########################################################################################
##
##  cdeploy – leichtgewichtiges Bash-kompatibles Installationssystem
##
##  Das Skript wurde als einfaches Hilfstool für Administratoren entwickelt, die häufig
##  ihre persönlichen Skripte und Daten auf zu wartenden Rechnern installieren, oder
##  Rechner einrichten müssen.
##
##  Features:
##  - einfach zu pflegende Installationspakete; bestehen aus gewöhnlichen Verzeichnissen
##  - globale (für alle Benutzer) oder lokale Installation
##  - Befehle: install, remove, create, pack, list, info
##  - Hooks erlauben die individuelle Erweiterung der Befehle install und remove
##  - Manifestdateien enthalten eine Liste aller installierten Dateien
##
## ========================================================================================
##
##  Diese Software steht unter der MIT-Lizenz:
##
##  MIT License
##
##  Copyright (c) 2025 Christian Dorn <https://github.com/cdorn-de>
##
##  Hiermit wird unentgeltlich jeder Person, die eine Kopie der Software und der
##  zugehörigen Dokumentationsdateien (die „Software“) erhält, die Erlaubnis erteilt,
##  uneingeschränkt mit der Software zu handeln, einschließlich und ohne Einschränkung
##  der Rechte, die Software zu verwenden, zu kopieren, zu modifizieren, zusammenzuführen,
##  zu veröffentlichen, zu vertreiben, zu unterlizenzieren und/oder zu verkaufen, und
##  Personen, denen die Software zur Verfügung gestellt wird, diese Rechte zu gewähren,
##  unter den folgenden Bedingungen:
##
##  Der obige Urheberrechtsvermerk und dieser Erlaubnisvermerk sind in allen Kopien oder
##  wesentlichen Teilen der Software beizulegen.
##
##  DIE SOFTWARE WIRD OHNE JEDE AUSDRÜCKLICHE ODER IMPLIZIERTE GARANTIE BEREITGESTELLT,
##  EINSCHLIESSLICH ABER NICHT BESCHRÄNKT AUF DIE GARANTIEN DER MARKTREIFE, DER EIGNUNG
##  FÜR EINEN BESTIMMTEN ZWECK UND DER NICHTVERLETZUNG. IN KEINEM FALL SIND DIE AUTOREN
##  ODER URHEBERRECHTSINHABER FÜR ANSPRÜCHE, SCHÄDEN ODER ANDERE HAFTUNGEN VERANTWORTLICH,
##  SEI ES AUFGRUND EINES VERTRAGS, UNERLAUBTER HANDLUNG ODER ANDERWEITIG, DIE AUS ODER
##  IM ZUSAMMENHANG MIT DER SOFTWARE ODER DER VERWENDUNG ODER ANDEREN GESCHÄFTEN MIT DER
##  SOFTWARE ENTSTEHEN.
##
## ========================================================================================
##
##  STRUKTUR
##  - Skript-Einstellungen
##  - Globale Variablen & Konstanten
##  - main()-Methode
##  - Dispatcher-Methoden
##  - Hilfsmethoden
##  - main()-Methode aufrufen
##
## ========================================================================================
##
##  RICHTLINIEN
##  - FOO_BAR   : globale Variable
##  - _FOO_BAR  : globale Konstante (readonly-Variable)
##  - foo_bar   : lokale Variable
##  - _foo_bar  : lokale Konstante (readonly-Variable)
##  - fooBar    : Methode
##
###########################################################################################




## ========================================================================================
## SKRIPT-EINSTELLUNGEN
## ========================================================================================

## Skript bei Bedarf im POSIX-Modus ausführen. Dazu müssen auch sämtliche Bash-spezifische
## Anweisungen durch POSIX-kompatible ersetzt werden!
#set -o posix


## Einstellungen für 'micro' Codeeditor (Einstellungen werden als Kommentare geschrieben!)
# shellcheck disable=SC1090     # Fehler: 'non-constant source' beim Laden von Dateien
# shellcheck disable=SC2317     # Fehler: Befehl unerreichbar
# shellcheck disable=SC2001     # Fehler: Bash-Anweisung nutzen; Skript soll POSIX-konform werden


# Abbruchkriterien für das Skript
#   -e          : Abbrechen wenn eine Anweisung einen Returncode ≠ 0 liefert.
#   -u          : Abbrechen wenn auf eine nicht definierte Variable zugegriffen wird.
#   -o pipefail : Eine Pipeline beim ersten Fehler abbrechen, nicht erst beim Letzten.
set -euo pipefail


# Feldseparator anpassen. Leerzeichen gelten anschließend nicht mehr als Trennzeichen
# -> Vorteil beim Parsen von Pfaden mit Leerzeichen.
IFS=$'\n\t'


# Es soll verhindert werden, dass ein noch aktives 'sudo' eine globale (De-)Installation
# ermöglicht. Aus diesem Grund werden alle aktiven 'sudo'-Sitzungen deaktiviert; das Skript
# muss bei Bedarf um eine neue Autorisierung bitten.
sudo -k




## ========================================================================================
## Globale Variablen & Kontanten
## ========================================================================================

# Konstanten
readonly _CDEP_SCRIPT_NAME="cdeploy"
readonly _CDEP_SCRIPT_VERSION="1.0"
readonly _CDEP_PACK_EXT=".cdp"       # Extension für Paket-Archive
readonly _CDEP_PACK_EXT_RE="\\.cdp"  # ...zur Verwendung mit RegEx
readonly _CDEP_SHELL_BIN="${SHELL:-/bin/sh}"


# Umgebungsvariablen
CDEP_PACKAGE_NAME="tools"
CDEP_PACKAGE_VERSION=""
CDEP_PACKAGE_CREATOR=""
CDEP_PACKAGE_URL=""
CDEP_PACKAGE_COPYRIGHT=""
CDEP_PACKAGE_DESCRIPTION=""
CDEP_BASE_GLOBAL="/usr/local"
CDEP_BASE_LOCAL="$HOME/.local"

# Interne Variablen
P_ACTION=""
P_BASE_TARGET=""
P_COUNT_CPY=0
P_COUNT_ERR=0
P_COUNT_WRN=0
P_ENV_PATH_SET=0
P_HOOK_PARAMETERS=""
P_MANIFEST_FILE=""
P_OPT_COMPRESSED=0
P_OPT_DRYRUN=0
P_OPT_FORCE=0
P_OPT_QUIET=0
P_OPT_SCOPE=""
P_OPT_USEHOOKS=0
P_OPT_VERBOSE=0
P_OPT_YES=0
P_OUTPUT=""
P_OUTPUT_FORMATTED=1
P_PACKAGE=""
P_PACKAGE_SOURCE=""
P_PACKAGE_INPUT=""
P_SHOW_SYNOPSIS=0
P_TARGET_BIN=""
P_TARGET_ETC=""
P_TARGET_HOOKS=""
P_TARGET_LIB=""
P_TARGET_MAN=""
P_TARGET_MANIFEST=""
P_TARGET_SYM=""
P_USE_PAGER=0
P_USE_SUDO=""

declare -ga P_TMP_OBJECTS=()

# Formatierungen
readonly _BOLD="\033[1m"
readonly _UNDER="\033[4m"
readonly _BLINK="\033[5m"
readonly _INVERT="\033[7m"
readonly _RESET="\033[0m"




## ========================================================================================
## main()-Methode
## ========================================================================================
main() {
    # Sicherstellen dass beim Beenden oder Abbrechen des Skriptes korrekt aufgeräumt wird.
    # Nur der Abbruch mit SIGKILL ('kill -9') lässt sich nicht abfangen.
    trap finalCleanup EXIT INT TERM HUP


    # Parameter parsen
    parseParameters "$@"


    # Aktion ausführen
    case "$P_ACTION" in
        create)
            commandCreate ;;
        help)
            commandShowHelpAndExit ;;
        info)
            commandShowPackageInfo ;;
        install)
            commandInstall ;;
        list)
            commandList ;;
        pack)
            commandPack ;;
        remove)
            commandRemove ;;
        version)
            commandShowVersionAndExit ;;
        *)
            showSyntaxAndExit "Ungültige oder unvolständige Anweisung" ;;
    esac

    quit 0
}


parseParameters() {
    # Wenn keine Parameter übergeben wurden, Syntax anzeigen und beenden
    if [[ $# -lt 1 ]]; then
        showSyntaxAndExit
    fi


    # Aktion auslesen; diese muss immer als erster Parameter gesetzt werden;
    # Syntax anzeigen und abbrechen, wenn eine unbekannte Aktion gefunden wird
    case "$1" in
        create)                 P_ACTION="create" ;;
        help|-h|--help)         P_ACTION="help" ;;
        info)                   P_ACTION="info" ;;
        install)                P_ACTION="install" ;;
        list|ls)                P_ACTION="list" ;;
        pack)                   P_ACTION="pack" ;;
        remove)                 P_ACTION="remove" ;;
        version|-V|--version)   P_ACTION="version" ;;
        *)                      showSyntaxAndExit "Unbekannte Aktion: $1" ;;
    esac

    shift  # ersten Parameter entfernen


    # Einige Aktionen benötigen keine weiteren Parameter. Bei diesen können wir hier
    # abbrechen. Sollten bei diesen Aktionen noch weitere Parameter angegeben sein,
    # wird eine Fehlermeldung ausgegeben.
    if [[ "$P_ACTION" =~ ^(help|list|version)$ ]]; then
        if [[ $# -gt 0 ]]; then
            showSyntaxAndExit "Diese Aktion benötigt keine Parameter: $P_ACTION"
        fi
        return 0
    fi

    # Alle anderen Aktionen benötigen weitere Parameter. Eine Fehlermeldung ausgeben
    # und abbrechen, Wenn keine Parameter mehr vorhanden sind.
    if [[ $# -lt 1 ]]; then
        showSyntaxAndExit "Ungültige oder unvollständige Anweisung"
    fi

    # Aktionen, die als letzten Parameter ein Installationspaket erwarten
    case "$P_ACTION" in
        info|install|pack)
            P_PACKAGE="${!#}"
            P_PACKAGE_INPUT="$P_PACKAGE"   # zur Anzeige für den Fall, dass $P_PACKAGE entpackt wird
            P_PACKAGE_SOURCE="$P_PACKAGE"  # zur Berechnung des Hash
            set -- "${@:1:$(($#-1))}"  # letzten Parameter entfernen

            # Datei herunterladen, wenn $P_PACKAGE eine URL ist
            # (http://, https://, ftp:// oder file://)
            local result
            result="$(downloadIfURL "$P_PACKAGE")" || cdepShowError $? "$result"
            P_PACKAGE="$result"

            # Datei extrahieren, wenn sie ein Archiv ist. Sicherstellen dass P_PACKAGE_SOURCE auf
            # das Archiv verweist, und nicht auf das entpackte Paket. Diese Information wird
            # zur Berechnung des Hash benötigt.
            result="$(extractPackage "$P_PACKAGE")" || cdepShowError $? "$result"
            P_PACKAGE_SOURCE="$P_PACKAGE"
            P_PACKAGE="$result"

            # Pfad prüfen und zurückgeben
            if [ "$P_PACKAGE" = "" ]; then
                cdepShowError 1 "Der Paketpfad konnte nicht korrekt verarbeitet werden."
            elif ! checkPackage; then
                cdepShowError 1 "Der Pfad zeigt nicht auf ein gültiges Installationspaket."
            fi

            # Das übergebene Paket ist ok. Lade die Konfigurationsdatei des Pakets und
            # berechnet die Ziel-Pfade für die Installation.
            loadConfigFile "${P_PACKAGE}/cdeploy.conf"
            ;;
        remove)
            # Hier wird der letzte Parameter als Name der Manifestdatei gewertet, deren
            # Installation entfernt werden soll. Der Wert wird einfach übernommen und erst
            # später weiter geprüft und verarbeitet.
            P_PACKAGE="${!#}"
            case "$P_PACKAGE" in
                *.manifest) P_PACKAGE="${P_PACKAGE%.manifest}" ;;
            esac
            P_PACKAGE_INPUT="$P_PACKAGE"      # zur Anzeige für den Fall, dass $P_PACKAGE entpackt wird
            P_PACKAGE_SOURCE="$P_PACKAGE"     # zur Berechnung des Hash
            CDEP_PACKAGE_NAME="${P_PACKAGE%-*}" # Versionsnummer für Projektnamen entfernen
            set -- "${@:1:$(($#-1))}"         # letzten Parameter entfernen
            ;;
        *)
            ;; # keine Aktion
    esac

    # Aktionen, die als letzten Parameter einen Ausgabepfad erwarten
    if [[ "$P_ACTION" =~ ^(create|pack)$ ]]; then
        P_OUTPUT="${!#}"
        set -- "${@:1:$(($#-1))}"  # letzten Parameter entfernen
    fi


    # Optionen normalisieren
    local opts=()

    for arg in "$@"; do
        case "$arg" in
            # Aktionen dürfen an dieser Stelle nicht mehr in der Parameterliste vorkommen,
            # die haben wir eingangs bereits ermittelt
            create|\
            help|-p|--help|\
            info|\
            install|\
            list|ls|\
            pack|\
            remove|\
            version|-V)
                    showSyntaxAndExit "Es wurde bereits eine Aktion definiert: $P_ACTION" ;;
            --)     break ;;
            --*)    # Langoption
                    opts+=("$arg")
                    ;;
            -*)     # Kurzoption oder Kombination
                    arg=${arg#-}
                    local char=""
                    while [ -n "$arg" ]; do
                        char=${arg%"${arg#?}"}  # erstes Zeichen
                        arg=${arg#?}            # Rest entfernen
                        opts+=("-$char")        # Zum Array hinzufügen
                    done
                    ;;
            *)      # Positionsargument - DARF NICHT MEHR VORKOMMEN!
                    showSyntaxAndExit "Unbekannte Option: $arg" ;;
        esac
    done


    # Optionen auswerten
    for arg in "${opts[@]}"; do
        case "$arg" in
            # Optionen
            --compressed|-c)
                assertAction compressed pack
                assertIsFalse "compressed" "$P_OPT_COMPRESSED"
                P_OPT_COMPRESSED=1 ;;
            --copyright=*)
                assertAction copyright create
                assertIsEmpty "copyright" "$CDEP_PACKAGE_COPYRIGHT"
                CDEP_PACKAGE_COPYRIGHT="${arg#*=}" ;;
            --creator=*)
                assertAction creator create
                assertIsEmpty "creator" "$CDEP_PACKAGE_CREATOR"
                CDEP_PACKAGE_CREATOR="${arg#*=}" ;;
            --description=*)
                assertAction description create
                assertIsEmpty "description" "$CDEP_PACKAGE_DESCRIPTION"
                CDEP_PACKAGE_DESCRIPTION="${arg#*=}" ;;
            --dry-run|-d)
                assertAction "dry run" install remove
                assertIsFalse "dry run" $P_OPT_DRYRUN
                P_OPT_DRYRUN=1 ;;
            --force|-f)
                assertAction force remove
                assertIsFalse "force" $P_OPT_FORCE
                P_OPT_FORCE=1 ;;
            --global|-g)
                assertAction scope install remove
                assertIsEmpty "scope" "$P_OPT_SCOPE"
                P_OPT_SCOPE="global" ;;
            --hook-parameters=*|-p=*)
                assertAction "hook parameters" install remove
                assertIsEmpty "hook parameters" "$P_HOOK_PARAMETERS"
                P_HOOK_PARAMETERS="${arg#*=}"
                P_HOOK_PARAMETERS="${P_HOOK_PARAMETERS%\"}"
                P_HOOK_PARAMETERS="${P_HOOK_PARAMETERS#\"}"
                P_HOOK_PARAMETERS="${P_HOOK_PARAMETERS%\'}"
                P_HOOK_PARAMETERS="${P_HOOK_PARAMETERS#\'}" ;;
            --local|-l)
                assertAction scope install remove
                assertIsEmpty "scope" "$P_OPT_SCOPE"
                P_OPT_SCOPE="local" ;;
            --name=*)
                assertAction name create
                CDEP_PACKAGE_NAME="${arg#*=}" ;;
            --quiet|-q)
                # für alle Aktionen erlaubt!
                assertIsFalse "quiet" $P_OPT_QUIET
                P_OPT_QUIET=1 ;;
            --url=*)
                assertAction url create
                assertIsEmpty "url" "$CDEP_PACKAGE_URL"
                CDEP_PACKAGE_URL="${arg#*=}" ;;
            --use-hooks|-u)
                assertAction "use hooks" install remove
                assertIsFalse "use hooks" $P_OPT_USEHOOKS
                P_OPT_USEHOOKS=1 ;;
            --verbose|-v)
                assertAction verbose info
                assertIsFalse "verbose" $P_OPT_VERBOSE
                P_OPT_VERBOSE=1 ;;
            --version=*)
                assertAction version create
                assertIsEmpty "projektversion" "$CDEP_PACKAGE_VERSION"
                CDEP_PACKAGE_VERSION="${arg#*=}" ;;
            --yes|-y)
                assertAction yes remove
                assertIsFalse "yes" $P_OPT_YES
                P_OPT_YES=1 ;;
            *)  # Alle anderen Optionen sind unbekannt! Syntax anzeigen und abbrechenl
                showSyntaxAndExit "Unbekanntes Argument: $arg" ;;
        esac
    done


    # Auf Vollständigkeit prüfen
    case "$P_ACTION" in
        install|remove)
            if [ -z "$P_OPT_SCOPE" ]; then
                showSyntaxAndExit "Es wurde kein Zielbereich angegeben."
            fi ;;
    esac
}




## ========================================================================================
## Dispatcher-Methoden
## ========================================================================================


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Ein leeres Installationspaket erstellen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
commandCreate() {
    # Zusammenfassung der Aufgabe anzeigen
    showTitle
    cdepShowMsg "Erzeuge leeres Installationspaket in" \
            "$(absPath "$P_OUTPUT")" \
            ""

    # Ausgabe prüfen
    if [[ -e "$P_OUTPUT" ]]; then
        cdepShowError 1 "Es gibt bereits ein Objekt mit diesem Namen."
    fi

    # Verzeichnisstruktur anlegen
    mkdir -p "$P_OUTPUT"/{bin,lib,etc,man,files} || {
        cdepShowError 1 "Das Verzeichnis konnte nicht angelegt werden."
    }

    # Leere Standard-Dateien erstellen
    local out="${P_OUTPUT}/cdeploy.conf"
    cat > "$out" <<EOF
## ================================================================================
## Config-Datei für das Installationsskript 'cdeploy'.
## Verwenden Sie diese Datei um ihre Installationspakete anzupassen.
## ================================================================================


## ==========
## Projektdaten
## ==========

## Projektname, wird u.a. zur Benennung des Zielordners verwendet.
$(makeConfigLine "CDEP_PACKAGE_NAME" "$CDEP_PACKAGE_NAME")

## Projektversion, wird für die Verwaltung der Installationen benötigt.
$(makeConfigLine "CDEP_PACKAGE_VERSION" "$CDEP_PACKAGE_VERSION")

## Ersteller
$(makeConfigLine "CDEP_PACKAGE_CREATOR" "$CDEP_PACKAGE_CREATOR")

## URL zur Webseite / zum Download
$(makeConfigLine "CDEP_PACKAGE_URL" "$CDEP_PACKAGE_URL")

## Copyright
$(makeConfigLine "CDEP_PACKAGE_COPYRIGHT" "$CDEP_PACKAGE_COPYRIGHT")

## Eine kurze Projektbeschreibung.
$(makeConfigLine "CDEP_PACKAGE_DESCRIPTION" "$CDEP_PACKAGE_DESCRIPTION")


## ==========
## INSTALLATIONS-ZIELE
## ==========

## Intallation für alle Benutzer (Parameter 'global').
#CDEP_BASE_GLOBAL="/usr/local"

## Installation für den ausführenden Benutzer (Parameter 'local').
#CDEP_BASE_LOCAL="$HOME/.local"


## ==========
## HOOKS
## Implementieren Sie die nachfolgenden Methoden, um den Installer
## noch weiter an Ihre Bedürfnisse anzupassen.
## ==========

## Wird direkt VOR der Installation eines Pakets ausgeführt.
#hookPreInstall() {
#}

## Wird direkt NACH der Intallation eines Pakets ausgeführt.
#hookPostInstall() {
#}


## Wird direkt VOR dem Entfernen eines Pakets ausgeführt.
#hookPreRemove() {
#}

## Wird direkt NACH dem Entfernen eines Pakets ausgeführt.
#hookPostRemove() {
#}
EOF


    out="${P_OUTPUT}/files/files.conf"
    cat > "$out" <<'EOF'
## Konfigurationsdatei für freies Kopieren von Dateien mit cdeploy.
## Verzeichnisse können mit dieser Funktion nicht kopiert werden.
##
## Definieren Sie in jeder Zeile einen Kopiervorgang, Leerzeilen und
## Kommentare ('#') werden ignoriert.
## Format: <source_file_name> <target_path>
##
## Siehe 'cdeploy help' für mehr Informationen.

# Beispiele:
# foo.txt ~/Dokumente
# bar.txt ~/Dokumente/
# digest ~/Dokumente/foobar.txt
EOF

    cdepShowMsg "Das Paket wurde erfolgreich erstellt."
}


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Installiert ein Paket
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
commandInstall() {
    # Zielverzeichnisse für die Installation ermitteln
    getInstallerTargets

    # Titel und Beschreibung der Aktion ausgeben
    showTitle

    local scope_str;  [[ "$P_OPT_SCOPE" == "global" ]] \
                        && scope_str="Globale" || scope_str="Lokale"
    cdepShowMsg "${scope_str} Installation von Paket '$(cdepGetPackageInfo "")'" \
            "aus Quelle $(absPath "$P_PACKAGE_INPUT")" \
            "" \
            ""

    # Warnung bei Verwendung von Hooks; Zugriffsrechte prüfen, ggf. Kennwort abfragen
    usesInstallHooks && showHookWarning
    checkPermissions

    P_SHOW_SYNOPSIS=1


    ##### AB HIER WERDEN WIRKLICH ÄNDERUNGEN VORGENOMMEN #####


    # Paketinformation für ein späteres Entfernen speichern
    saveRemoveHooks "${P_PACKAGE}/cdeploy.conf"

    # Hook vor der Installation ausführen
    if isOverridden hookPreInstall; then
        cdepShowMsg "Pre-Install Hook ausführen"
        hookPreInstall
        cdepShowMsg ""
    fi


    # Wenn eine lokale Installation stattfindet, sicherstellen, dass
    # die lokalen Pfade ~/.local/bin in $PATH und ~/.local/share/man
    # in $MANPATH vorhanden sind
    if [[ "$P_OPT_SCOPE" == "local" ]]; then
        ensureLocalPath PATH "$HOME/.local/bin"
        ensureLocalPath MANPATH "$HOME/.local/share/man"
    fi


    # Verzeichnis ./bin kopieren
    src="${P_PACKAGE}/bin"
    if [ -d "$src" ] && [ "$(ls -A "$src")" ]; then
        cdepShowMsg "Kopiere Programme..."
        copyFiles "bin" "$src" "$P_TARGET_BIN"
        # Anstatt die PATH-Variable anzupassen legen wir Symlinks in
        # ~/.local/bin bzw. /usr/local/bin an – abhängig vom P_OPT_SCOPE.
        # Diese beiden Pfade sind normalerweise immer in PATH enthalten.
        cdepShowMsg "  => Erstelle Symlinks..."
        makeSymlinks "$P_TARGET_BIN" "$P_TARGET_SYM"
        cdepShowMsg ""
    fi

    # Verzeichnis ./lib kopieren
    src="${P_PACKAGE}/lib"
    if [ -d "$src" ] && [ "$(ls -A "$src")" ]; then
        cdepShowMsg "Kopiere Bibliotheken..."
        copyFiles "lib" "$src" "$P_TARGET_LIB"
        cdepShowMsg ""
    fi

    # Verzeichnis ./etc kopieren
    src="${P_PACKAGE}/etc"
    if [ -d "$src" ] && [ "$(ls -A "$src")" ]; then
        cdepShowMsg "Kopiere Konfigurationsdateien..."
        copyFiles "etc" "$src" "$P_TARGET_ETC"
        cdepShowMsg ""
    fi

    # Man-Pages installieren
    src="${P_PACKAGE}/man"
    if [ -d "$src" ] && [ "$(ls -A "$src")" ]; then
        cdepShowMsg "Installiere Man-Pages..."
        installManpages "$src"
        cdepShowMsg ""
    fi

    # Freies Kopieren von Dateien
    src="${P_PACKAGE}/files"
    if [ -d "$src" ] && [ "$(ls -A "$src")" ]; then
        cdepShowMsg "Kopiere Dateien..."
        freeCopy "${src}/files.conf" "$src"
        cdepShowMsg ""
    fi

    # Hook nach der Installation ausführen
    if isOverridden hookPostInstall; then
        cdepShowMsg "" "Post-Install Hook ausführen"
        hookPostInstall
    fi


    cdepShowMsg "" "Installation abgeschlossen."
    case $P_COUNT_CPY in
        0)  cdepShowMsg "Es wurden keine Dateien kopiert"  ;;
        1)  cdepShowMsg "Es wurde 1 Datei kopiert." ;;
        *)  cdepShowMsg "Es wurden ${P_COUNT_CPY} Dateien kopiert." ;;
    esac
}


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Alle installierten Pakete – getrennt nach lokal/global – auflisten
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
commandList() {
    local list

    # Ausgabe für Anzeige mit Pager (less/more) im Terminalfenster
    if isFalse "$P_OPT_QUIET"; then
        P_OUTPUT_FORMATTED=1
        P_USE_PAGER=1
        list="$(makePackageList)"
        echo "$list" | usePager
    fi

    # Ausgabe für Umleitung in Datei
    if [ ! -t 1 ]; then
        P_OUTPUT_FORMATTED=0
        P_USE_PAGER=0
        list="$(makePackageList)"
        echo "$list"
    fi
}


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Erstellt eine .cdp-Archivdatei aus einem Installationsverzeichnis
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
commandPack() {
    # Zusammenfassung der Aufgabe anzeigen
    showTitle

    local project_info;  project_info="$(cdepGetPackageInfo)"
    if [[ "$P_OPT_COMPRESSED" -eq 1 ]]; then
        cdepShowMsg "Erstelle komprimiertes Installationsarchiv für Paket ${project_info}." ""
    else
        cdepShowMsg "Erstelle Installationsarchiv für Paket ${project_info}." ""
    fi

    # Archiv-Extension zum Pfad hinzufügen, wenn nötig;
    local filename="${P_OUTPUT%"$_CDEP_PACK_EXT"}$_CDEP_PACK_EXT"
    filename="$(absPath "$filename")"

    # Pfade ausgeben
    cdepShowMsg "Quelle..: $(absPath "$P_PACKAGE_INPUT")" \
            "Ziel....: $(absPath "$filename")" \
            "" \
            ""

    # Zielpfad prüfen
    if [[ -z "$P_OUTPUT" ]]; then
        cdepShowMsg "Es wurde kein Zielpfad angegeben."
    elif [[ -e "$filename" ]]; then
        if [[ -d "$filename" ]]; then
            cdepShowError 1 "Es gibt bereits ein Verzeichnis mit diesem Namen." \
                        "Verzeichnisse können nicht überschrieben werden."
        fi
    fi

    # Variablen prüfen
    for var in CDEP_PACKAGE_NAME P_OUTPUT; do
        validateVar "$var"
    done

    # Installationspaket verpacken
    if [[ "$P_OPT_COMPRESSED" -eq 1 ]]; then
        # gzip-komprimiert
        tar -czf "$filename" -C "$P_PACKAGE" . || \
            cdepShowError 1 \
                "Fehler beim Erstellen des komprimierten Installationspakets." \
                "$P_OUTPUT"
    else
        # schnell, unkomprimiert
        tar -cf "$filename" -C "$P_PACKAGE" . || \
            cdepShowError 1 \
                "Fehler beim Erstellen des Installationspakets." \
                "$P_OUTPUT"
    fi

    cdepShowMsg "Das Installationsarchiv wurde erfolgreich erstellt."
}


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Entfernt ein installiertes Paket
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
commandRemove() {
    # Titel und Beschreibung der Aktion ausgeben
    showTitle

    local scope_str;  [[ "$P_OPT_SCOPE" == "global" ]] \
                        && scope_str="global" || scope_str="lokal"

    cdepShowMsg "Entferne ${scope_str}e Installation von Paket '${P_PACKAGE}'." \
            "" \
            ""


    # Hook und Manifestdatei merken, müssen ganz zum Schluss entfernt werden.
    local manifest_file;  manifest_file="$(getCdeployDir "$P_OPT_SCOPE")/manifests/${P_PACKAGE}.manifest"
    local hook_file;  hook_file="$(getCdeployDir "$P_OPT_SCOPE")/hooks/${P_PACKAGE}.hook"

    # Manifestdatei einlesen
    local manifest
    if ! manifest="$(getManifestContent "$P_PACKAGE".manifest "$P_OPT_SCOPE")"; then
        cdepShowError 1 "Es wurde keine ${scope_str}e Installation von '${P_PACKAGE}' gefunden." \
                    "Verwenden Sie 'cdeploy list' um alle installierten Pakete anzuzeigen."
    fi


    # Sicherheitsabfrage und ggf. Bestätigung
    if isFalse "$P_OPT_YES"; then
        cdepShowMsg "   Möchten Sie die ${scope_str}e Installation von '${P_PACKAGE}'" \
                "   wirklich entfernen? Dieser Vorgang kann nicht widerrufen werden!" \
                "" \
                "   Wenn Sie das Paket entfernen möchten, tippen Sie \"ja\"." \
                "   Mit jeder anderen Eingabe brechen Sie den Vorgang ab."
        printf  '   > '; IFS= read -r choice
        if [ "$(toLowercase "$choice")" != "ja" ]; then
            cdepShowMsg "" "   (Vorgang vom Benutzer abgebrochen.)" ""
            quit 2
        fi

        cdepShowMsg "" \
                "" \
                "   (Paket '${P_PACKAGE}' wird entfernt.)" \
                "" \
                ""
    fi


    # Gespeicherte Paketinformation inkl. Remove-Hooks auslesen; dazu brauchen wir den Hash
    # für die Hookdatei, der an 'loadRemoveHooks' übergeben wird.
    local h_hsh h_category
    while IFS="$(printf '\t')" read -r _ h_hsh _ _ _ _ h_category _; do
        if [ "$h_category" != "hook" ]; then h_hsh=""; fi
        break  # Nur erste Zeile prüfen
    done <<EOF
$manifest
EOF

    loadRemoveHooks "$h_hsh"
    getInstallerTargets

    # Warnung bei Verwendung von Hooks; Zugriffsrechte prüfen, ggf. Kennwort abfragen
    usesRemoveHooks && showHookWarning
    checkPermissions

    P_SHOW_SYNOPSIS=1


    ##### AB HIER WERDEN WIRKLICH ÄNDERUNGEN VORGENOMMEN #####


    # Status-Variablen definieren
    local file_count=0
    local err_count=0
    local err_hash=0
    local err_inuse=0
    local err_invalid=0
    local err_notfound=0
    local err_rm=0

    # Hook vor dem Entfernen ausführen
    if isOverridden hookPreRemove; then
        cdepShowMsg "Pre-Remove Hook ausführen"
        hookPreRemove
        cdepShowMsg ""
    fi

    # Alle Manifeste zum Paket auslesen. Diese Information wird benötigt um festzustellen,
    # ob eine Datei in mehreren installierte Versionen eines Pakets vorkommt.
    local package_name="${P_PACKAGE%-[0-9]*}"
    local all_manifests
    all_manifests="$(
        getManifestContent "${package_name}" "local" 2>/dev/null || true
        getManifestContent "${package_name}" "global" 2>/dev/null || true
        )"

    # Manifest zeilenweise verarbeiten, Datei(en) entfernen;
    # Zur Erinnerung: Leer- und Kommentarzeilen wurden beim Einlesen
    #                 der Manifeste bereits ignoriert!
    # Zur Erinnerung: "hash" kann nicht als Variablenname verwendet werden, weil es
    #                 u.U. mit einer Shell-Funktion gleichen Namens kollidiert! => $hsh
    local current_hash=""
    local occurences

    while IFS="$(printf '\t')" read -r m_filepath m_hsh m_pname m_pversion m_scope _ m_cat _; do
        # Sonderfall Hookdatei: überspringen
        [ "$m_cat" = "hook" ] && continue
        # Falls alle Werte leer sind (z. B. nach letzten Zeilenumbruch) -> überspringen
        [ -z "$m_filepath$m_hsh$m_pname$m_pversion$m_scope" ] && continue
        file_count=$((file_count + 1))

        # Jede Spalte prüfen – wenn eine fehlt, Fehler zählen und überspringen
        if [ -z "$m_filepath" ] || [ -z "$m_hsh" ] || [ -z "$m_pname" ] || [ -z "$m_pversion" ] || [ -z "$m_scope" ]; then
            cdepShowWarning "Ungültiger Manifest-Eintrag. Eintrag wird übersprungen."
            err_invalid=$((err_invalid + 1))
            continue
        fi

        # Existenz der Datei und ggf. Hash prüfen
        if [ ! -L "$m_filepath" ]; then
            if [ ! -e "$m_filepath" ]; then
                cdepShowWarning "Nicht gefunden: $m_filepath"
                err_notfound=$((err_notfound + 1))
                continue
            fi

            current_hash="$(getFileHash "$m_filepath")"
            if isFalse "$P_OPT_FORCE" && [ "$current_hash" != "$m_hsh" ]; then
                cdepShowWarning "Überspringe $m_filepath (Hash abweichend)"
                err_hash=$((err_hash + 1))
                continue
            fi
        fi

        # Prüfen ob die Datei noch in anderen Paketversionen verwendet wird.
        # Da $all_manifests auch die Manifestdatei für das zu löschende Paket enthält, kommt
        # jede Datei mindestens einmal darin vor. Wir müssen also suche, bis eine Datei
        # zum zeitenmal gefunden wird...
        occurences=0
        while IFS="$(printf '\t')" read -r o_filepath _; do
            [ "$m_filepath" = "$o_filepath" ] && occurences=$((occurences + 1))
            [ "$occurences" -ge 2 ] && break
        done <<EOF
$all_manifests
EOF

        # Wenn die Datei von mehreren Paketversionen verwendet wird,
        # mit nächster Datei fortfahren
        if [ "$occurences" -gt 1 ]; then
            err_inuse=$((err_inuse + 1))
            continue
        fi

        # Datei entfernen
        if isTrue "$P_OPT_DRYRUN"; then
            cdepShowMsg "  X  $m_filepath"
        elif cdepSafeRun rm -f "$m_filepath"; then
            cdepShowMsg "  X  $m_filepath"
            removeDir "$(dirname "$m_filepath")"
        else
            cdepShowWarning "Löschen fehlgeschlagen: $m_filepath"
            err_rm=$((err_rm + 1))
        fi
    done <<EOF
$manifest
EOF


    # Hook nach dem Entfernen ausführen
    if isOverridden hookPostRemove; then
        cdepShowMsg "" "Post-Remove Hook ausführen"
        hookPostInstall
    fi


    # Projektverzeichnis, Manifestdatei und Hookdatei entfernen, wenn möglich
    if isTrue "$P_OPT_DRYRUN"; then
        echo
        cdepShowMsg "  X  HOOKDATEI $hook_file"
        cdepShowMsg "  X  PROJEKTVERZEICHNIS $P_BASE_TARGET"
        cdepShowMsg "  X  MANIFESTDATEI $manifest_file"
    else
        echo
        [ ! -e "$hook_file" ] && hook_file="${hook_file}.gz"
        cdepSafeRun rm -f "$hook_file" "MSG:  X  HOOKDATEI $hook_file"
        removeDir "$P_TARGET_HOOKS"
        cdepSafeRun rm -f "$manifest_file" "MSG:  X  MANIFESTDATEI $manifest_file"
        removeDir "$P_TARGET_MANIFEST"
        removeDir "$(getCdeployDir "$P_OPT_SCOPE")"
        removeDir "$P_BASE_TARGET" "  X  PROJEKTVERZEICHNIS $P_BASE_TARGET"
    fi

    # Abschluss
    err_count=$((err_hash + err_notfound + err_invalid + err_rm ))
    if [ "$err_count" -eq 0 ]; then
        cdepShowMsg "" \
                "" \
                "Das Paket '$P_PACKAGE' wurde entfernt."
    else
        cdepShowMsg "" \
                "" \
                "Das Paket '$P_PACKAGE' konnte nicht vollständig entfernt werden."
    fi

    case "$err_hash" in
        0) ;;  # keine Ausgabe
        1) cdepShowMsg  \
            "" \
            "Hinweis: Eine Datei wurde nicht entfernt, da sie seit der Installation" \
            "         geändert wurde. Diese Datei kann mit der Option '--force'"\
            "         entfernt werden." ;;
        *) cdepShowMsg \
            "" \
            "Hinweis: $err_hash Dateien wurden nicht entfernt, da sie seit der Installation" \
            "         geändert wurden. Diese Dateien können mit der Option '--force'" \
            "         entfernt werden." ;;
    esac

    case "$err_inuse" in
        0) ;; # keine Ausgabe
        1) cdepShowMsg \
            "" \
            "Hinweis: Eine Datei wurde nicht entfernt, da sie von mindestens einer weiteren" \
            "         Version des Pakets '$P_PACKAGE' verwendet wird." ;;
        *) cdepShowMsg \
            "" \
            "Hinweis: $err_inuse Dateien wurden nicht entfernt, da sie von mindestens einer" \
            "         weiteren Version des Pakets '$P_PACKAGE' verwendet wird." ;;
    esac

    local remaining;  remaining=$((err_invalid + err_notfound ))
    case "$remaining" in
        0) ;; # keine Ausgabe
        1) cdepShowMsg  "" \
                    "Hinweis: Eine Datei wurde nicht gefunden." ;;
        *) cdepShowMsg  "" \
                    "Hinweis: $remaining Dateien wurden nicht gefunden." ;;
    esac

    case "$err_rm" in
        0) ;; # keine Ausgabe
        1) cdepShowMsg  "" \
                    "Hinweis: Eine Datei konnte nicht gelöscht werden." ;;
        *) cdepShowMsg  "" \
                    "Hinweis: $err_rm Dateien konnten nicht gelöscht werden." ;;
    esac

    quit 0
}


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Hilfeseite (Manpage) anzeigen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
commandShowHelpAndExit() {
    groff -man -Tutf8 -k <<'EOF' | less -R
.TH CDEPLOY 1 "Oktober 2025" "Version 1.0" "Benutzerbefehle"
.SH NAME
.TP 10
cdeploy –
leichtgewichtiges, Bash-kompatibles Deployment-System für Softwarepakete
.SH ÜBERSICHT
.B cdeploy
\fIBEFEHL\fR [\fIOPTIONEN\fR] [\fIARCHIV\fR] [\fIPAKET\fR]
.SH BESCHREIBUNG
\fBcdeploy\fR ist ein leichtgewichtiges, portables Deployment-System für Softwarepakete, das vollständig als Bash-kompatibles Shell-Skript umgesetzt ist.

Es ermöglicht lokale und globale Installationen und verwaltet installierte Dateien über transparente Manifestdateien mit Hash-Prüfsummen. Für die globale Installation werden Administratorrechte benötigt.

Das System verzichtet bewusst auf externe Abhängigkeiten und verwendet ausschließlich Standard-Unix-Werkzeuge. Es ist daher vor allem für Administratoren interessant, die es zum Einrichten und Warten von Rechnern verwenden können.

.I PAKETSTRUKTUR
.LP
Die typische Struktur eines cdeploy-Pakets ist wie folgt:

.RS
.nf
<Paket>
   |- cdeploy.conf          # Umgebungsvariablen und Hooks
   |- bin                   # Programme und Skripte
   |- etc                   # Konfigurationsdateien
   |- files                 # Sonstige Dateien
   |    |- files.conf       # Zielverzeichnisse der Dateien
   |- lib                   # Bibliotheken
   |- man                   # Man-Pages
.fi
.RE

Bei der Installation wird für jedes Paket ein eigenes Verzeichnis angelegt, in das die Verzeichnisse \fIbin\fR \fIetc\fR \fIlib\fR und \fIman\fR kopiert werden. Damit nicht jedes installierte Paket in die PATH Variable aufgenommen werden muss, wird – abhängig von der verwendeten Option --local oder --global – in ~/.local/bin oder /usr/local/bin ein Symlink auf jede Datei im Verzeichnis \fIbin\fR angelegt.

Die Zielverzeichnisse der Dateien in \fIfiles\fR werden in der Datei \fIfiles.conf\fR definiert. Sie können frei gewählt werden. Wenn der aktuelle Benutzer keinen Zugriff auf eines der Zielverzeichnisse hat, wird das sudo-Kennwort abgefragt.

.SH BEFEHLE
.TP
.B create\fR [optionen] \fIPAKET\fR
Legt ein leeres Installationspaket (Template) als Verzeichnis an. In dieses Verzeichnis können alle zu installierenden Dateien kopiert werden. Die Konfigurationsdateien ./cdeploy.conf und ./files/files.conf helfen bei der weiteren Konfiguration des Pakets.

Zum Verpacken in einem Archiv für die Weitergabe an Dritte, siehe Befehl \fIpack\fR.
.TP
.B help
Gibt diese Hilfeseite aus.
.TP
.B info\fR [optionen] \fIPAKET\fR
Zeigt die Metadaten eines Pakets an (\fIName Version Ersteller Quelle/URL Hash Copyright Beschreibung\fR). (Siehe auch Option --verbose.)
.TP
.B install\fR [optionen] \fIPAKET\fR
Installiert ein Paket aus einem lokalen Verzeichnis, einer lokalen Datei oder einer URL. Es muss zwingend eine der beiden Option --local oder --global verwendet werden.

Die Funktionalität von \fBinstall\fR kann durch vor- und/oder nachgeschaltete Skripte (Hooks) erweitert werden. Wegen der potentiellen Gefahrenquelle wird vor der Verwendung von Hooks eine Warnmeldung ausgegeben, die bestätigt werden muss. (Siehe auch Option --use-hooks.)

Während der Installation wird eine Manifestdatei erstellt, die alle installierten Dateien inklusive deren Hash-Werten enthält. Das Manifest erleichtert das spätere Entfernen eines Pakets und schützt dabei manuell geänderte Datein.
.TP
.B list
Listet alle installierten Pakete und Versionen auf.
.TP
.B pack\fR [optionen] \fIARCHIV PAKET\fR
Erstellt eine Archivdatei (.cdp) von einem offenen Installationsverzeichnis. Die Archivdatei bietet sich vor allem zur Weitergabe an Dritte an.
.TP
.B remove\fR [optionen] \fIPAKET\fR
Entfernt ein installiertes Paket. Neben dem Paketnamen muss zwingend eine der beiden Optionen --local oder --global verwenendet werden.

Standardmäßig werden keine Dateien entfernt, die nach ihrer Installation geändert wurden (siehe auch Option --force). Außerdem werden keine Dateien entfernt, die noch Teil mindestens einer weiteren Version des Pakets sind.

Die Funktionalität von \fBremove\fR kann durch vor- und/oder nachgeschaltete Skripte (Hooks) erweitert werden. Wegen der potentiellen Gefahrenquelle wird vor der Verwendung von Hooks eine Warnmeldung ausgegeben, die bestätigt werden muss (siehe auch Option --use-hooks).

Erfordert vor dem Entfernen eine Bestätigung.
.TP
.B version
Zeigt die Versions- und Copyright-Informationen von \fBcdeploy\fR an.

.SH OPTIONEN
.TP
.B --compressed | -c \fR--- (Befehl: pack)
Erstellt ein komprimiertes Archiv. Standardmäßig werden Archive unkomprimiert erstellt, da sie zwar größer sind, aber schneller verarbeitet werden können. Komprimierte Archive sind dagegen kleiner, aber in der Verarbeitung langsamer.
.TP
.B --copyright=".." \fR--- (Befehl: create)
Trägt beim Erstellen eines leeren Pakets die Copyright-Informationen ein. Diese Option ist sinnvoll, wenn \fBcdeploy\fR über ein anderes Skript ausgeführt wird.
.TP
.B --creator=".." \fR--- (Befehl: create)
Trägt beim Erstellen eines leeren Pakets den Namen des Erstellers ein. Diese Option ist sinnvoll, wenn \fBcdeploy\fR über ein anderes Skript ausgeführt wird.
.TP
.B --description=".." \fR--- (Befehl: create)
Trägt beim Erstellen eines leeren Pakets eine Beschreibung ein. Diese Option ist sinnvoll, wenn \fBcdeploy\fR über ein anderes Skript ausgeführt wird.
.TP
.B --dry-run | -d \fR--- (Befehle: install, remove)
Führt einen Testlauf für die Installation/das Entfernen eines Pakets aus. Es werden hierbei keine Dateien hinzugefügt, entfernt oder geändert!
.TP
.B --force | -f \fR--- (Befehl: remove)
Standardmäßig werden beim Entfernen keine Dateien gelöscht, die seit ihrer Intallation geändert wurden. Mit --force werden auch diese Dateien entfernt.
.TP
.B --global | -g \fR--- (Befehle: install, remove)
Führt die Installation oder Entfernung im globalen cdeploy-Verzeichnis aus (erfordert \fBsudo\fR).
.TP
.B --hook-parameters=".." | -p=".." \fR--- (Befehle: install, remove)
Spezifiziert Parameter für die definierten Hooks. Siehe Abschnitt \fBHOOKS\fR für mehr Informationen.
.TP
.B --local | -l \fR--- (Befehle: install, remove)
Führt die Operation im benutzerspezifischen Verzeichnis aus.
.TP
.B --name=".." \fR--- (Befehl: create)
Trägt beim Erstellen eines leeren Pakets den Paketnamen ein. Diese Option ist sinnvoll, wenn \fBcdeploy\fR über ein anderes Skript ausgeführt wird..TP
.B --quiet | -q
Unterdrückt alle Ausgaben, Warn- und Fehlermeldungen. Diese Option ist sinnvoll, wenn \fBcdeploy\fR über ein anderes Skript ausgeführt wird.
.TP
.B --url=".." \fR--- (Befehl: create)
Trägt beim Erstellen eines leeren Pakets die Download-URL ein. Diese Option ist sinnvoll, wenn \fBcdeploy\fR über ein anderes Skript ausgeführt wird.
.TP
.B --use-hooks | -u \fR--- (Befehle: install, remove)
Erlaubt die Nutzung von Hooks und verhindert die Sicherheitsabfrage bei der Ausführung. Diese Option ist sinnvoll, wenn \fBcdeploy\fR über ein anderes Skript ausgeführt wird.
.TP
.B --verbose | -v \fR--- (Befehl: info)
Gibt zusätzlich zu den Metadaten eines Pakets auch alle enthaltenen Dateien und deren Zielverzeichnisse aus.
.TP
.B --version=".." \fR--- (Befehl: create)
Trägt beim Erstellen eines leeren Pakets die Paketversion ein. Diese Option ist sinnvoll, wenn \fBcdeploy\fR über ein anderes Skript ausgeführt wird.
.TP
.B --yes | -y \fR--- (Befehl: remove)
Beantwortet die Sicherheitsabfrage zum Entfernen eines Pakets automatisch mit 'ja'. Diese Option ist sinnvoll, wenn \fBcdeploy\fR über ein anderes Skript ausgeführt wird.


.SH DATEIEN
.TP
~/.local/PAKET
Standardpfad für lokale Installationen. Kann über die Paket-Konfigurationsdatei geändert werden.
.TP
/usr/local/PAKET
Standardpfad für globale Installationen. Kann über die Paket-Konfigurationsdatei geändert werden.
.TP
~/.local/share/cdeploy
Lokaler Ordner mit internen Informationen zu den Installationen. Wird in den nachfolgenden Pfaden mit @ symbolisiert.
.TP
/usr/local/share/cdeploy
Globaler Ordner mit internen Informationen zu den Installationen. Wird in den nachfolgenden Pfaden mit @ symbolisiert.
.TP
@/manifests/MANIFEST
Einthält die vom Paket installierten Dateien inklusive Prüfsummen. (@ = cdeploy-Verzeichnis)
.TP
@/hooks/HOOKDATEI
Optional. Enthält die für das Entfernen eines Pakets benötigten Hooks, sofern ein Paket sie implementiert hat. (@ = cdeploy-Verzeichnis)

.SH HOOKS
Hooks sind optionale Shell-Skripte, die von einem Paket implementiert werden können, um den Installations- oder Entfernungsprozess zu erweitern. Die folgenden Hook-Typen werden unterstützt:
.TP
.B pre- und post-install
Wird vor bzw. nach der Installation ausgeführt.
.TP
.B pre- und post-remove
Wird vor bzw. nach dem Entfernen eines Pakets ausgeführt.
.RE
.sp
Hooks werden über gespeicherte SHA256-Hashes im Manifest verifiziert.
.br
Vor der Ausführung erfolgt eine Sicherheitswarnung.
.LP
.B HOOK-PARAMETER
.br
Über den Parameter \fB--hook-parameters\fR (kurz: \fB-p\fR) lassen sich Parameter speziell für Hooks übergeben, ohne dass diese mit den herkömmlichen Parametern von \fBcdeploy\fR kollidieren können.

Innerhalb von \fB--hook-parameters\fR können beliebige Schlüssel-Werte-Paare definiert werden. Wenn die Werte Leer- oder Sonderzeichen enthalten, müssen sie mit einfachen ('') oder doppelten ("") Anführungszeichen begrenzt werden. Innerhalb einfacher Quotes dürfen doppelte Anführungszeichen vorkommen und umgekehrt. Das Paragraphenzeichen (§) ist als Trenner zwischen Parametern reserviert und darf im Wert nicht vorkommen.
.sp
\fIBeispiele\fR
.nf
§user=admin
§desc="Neuer Benutzer"
§info='erstellt mit "Standardrechten"'
.fi

.B HOOK-API
.br
Für Programmierung von Hooks gibt es verschiedene Hilfsmethoden. Besonders die Methoden zur Ausgabe von Meldungen (\fIcdepShowMessage cdepShowError\fR und \fIcdepShowWarning\fR) sollten verwendet werden, da sie direkt in das Fehlermanagement von \fBcdeploy\fR greifen.

Neben den hier gelisteten Methoden können auch die weiter unten beschriebenen Umgebungsvariablen in Hooks verwendet werden. Sie dienen zur Beschreibung des Pakets und zur Generierung der Installationspfade und Manifest- und Hookdateien.
.TP
cdepGetBaseTarget
Liefert das Basis-Installationsverzeichnis.
.TP
cdepGetHookParameter\fR <name> [default]
Liefert den Wert des Hook-Parameters \fIname\fR (siehe auch: --hook-parameters). Über den optionalen Parameter \fIdefault\fR kann ein Standardwert übergeben werden, für den Fall, dass der Parameter nicht existiert. Wenn \fIdefault\fR nicht angegeben wird, wird ein leerer String zurückgegeben.
.TP
cdepGetPackageInfo\fr [divider]
Liefert den Paketnamen zusammen mit der Versionsnummer. Der Optionale Parameter \fIdivider\fR definiert das Trennzeichen zwischen beiden Angaben. Standardmäßig wird ein Bindestrich (`-`) verwendet.
.TP
cdepSafeRun\fR <command> ['MSG:'<success_message]
Führt (Datei-)Befehle sicher aus und verwendet 'sudo' wenn nötig, und es beim Skriptstart erfolgreich aktiviert wurde. Gibt bei Fehlern automatisch eine Fehlermeldung aus. Die Methode beendet bei einem Fehler \fInicht\fR automatisch das Skript, sondern gibt einen Returncode ungleich 0 zurück.
.br
Optional kann im letzten Parameter eine Meldung übergeben werden, die angezeigt wird, wenn die Anweisung erfolgreich ausgeführt wurde. Dieser Parameter muss mit der Zeichenfolge 'MSG:' beginnen.
.TP
cdepShowError\fR <error_code> [message ...]
Für die Ausgabe von Fehlermeldungen. Der erste Parameter ist ein Fehlercode, darauf folgen beliebig viele Parameter, die jeweils als eigene Textzeile ausgegeben werden. Wenn der Fehlercode \fB<> 0\fR ist, wird das Skript mit diesem Fehlercode beendet.
.TP
cdepShowMsg\fR [message ...]
Für die Ausgabe von normalen Statusmeldungen. Es kann eine beliebige Anzahl Parameter übergeben werden, die jeweils als eigene Textzeile ausgegeben werden.
.TP
cdepShowWarning\fR [message ...]
Für die Ausgabe von Warnungen. Es kann eine beliebige Anzahl Parameter übergeben werden, die jeweils als eigene Textzeile ausgegeben werden.

.SH RÜCKGABEWERTE
.TP
0
Das Skript wurde erfolgreich ausgeführt.
.TP
1
Ein Fehler ist aufgetreten.
.TP
2
Das Skript wurde vom Benutzer abgebrochen.

.SH UMGEBUNGSVARIABLEN & KONSTANTEN
Konstanten beginnen mit einem Unterstrich (_) und können nicht geändert werden. Die Umgebungsvariablen sollten über die Konfigurationsdatei \fIcdeploy.conf\fR im Installationspaket definiert werden.
.TP
_CDEP_SCRIPT_NAME
Enthält den Namen des Skripts ("cdeploy").
.TP
_CDEP_SCRIPT_VERSION
Enthält die Versionsnummer des Skripts.
.TP
_CDEP_PACK_EXT
Enthält die Extension für Archivdateien (.cdp).
.TP
_CDEP_PACK_EXT_RE
Enthält abenfalls die Extension für Archivdateien, aber in einem Format zur Verwendung mit regulären Ausdrücken.
.TP
_CDEP_SHELL_BIN
Enthält die verwendete Shell.
.TP
CDEP_PACKAGE_NAME
Der Name für das Installationspaket.
.TP
CDEP_PACKAGE_VERSION
Die Versionsnummer des Installationspakets.
.TP
CDEP_PACKAGE_CREATOR
Der Ersteller des Installationspakets.
.TP
CDEP_PACKAGE_URL
Die Download-URL des Installationspakets.
.TP
CDEP_PACKAGE_COPYRIGHT
Die Copyright-Information zum Installationspaket.
.TP
CDEP_PACKAGE_DESCRIPTION
Eine Beschreibung des Installationspakets.
.TP
CDEP_BASE_LOCAL
Enthält das Standardbasisverzeichnis für lokale Installationen.
.TP
CDEP_BASE_GLOBAL
Enthält das Standardbasisverzeichnis für globale Installationen.

.SH BEISPIELE
.TP
cdeploy install --local ./meinpaket.cdp
.EX
Lokale Installation eines Pakets.
.EE
.TP
cdeploy install --global ./meinpaket.cdp
.EX
Globale Installation eines Pakets.
.EE
.TP
cdeploy install --local --hook-parameters="§name='John Doe'
           $firma="ACME Corp." $alter=42" ./meinpaket.cdp
.EX
Installation mit Parametern für einen Hook.
.EE
.TP
cdeploy list
.EX
Auflisten aller installierten Pakete.
.EE
.TP
cdeploy remove meinpaket-1.0
.EX
Entfernen eines Pakets. Es muss der Paketname inkl. Paketversion
angegeben werden (siehe auch: \fBcdeploy list\fR).
.EE
.TP
cdeploy pack ./meinarchiv.cdp ./meinpaket
.EX
Eine Archivdatei erstellen.
.EE
.TP
cdeploy info ./meinpaket.cdp
.EX
Informationen zu einem Paket abfragen.
.EE

.SH AUTOR
Christian Dorn <https://github.com/cdorn-de>

.SH LIZENZ
.LP
cdeploy ist freie Software. Sie darf unter den Bedingungen der MIT-Lizenz genutzt, kopiert,
verändert und weitergegeben werden.
.LP
Copyright (c) 2025 Christian Dorn <https://github.com/cdorn-de>
.LP
Hiermit wird unentgeltlich jeder Person, die eine Kopie der Software und der zugehörigen
Dokumentationsdateien (die „Software“) erhält, die Erlaubnis erteilt, uneingeschränkt mit
der Software zu handeln, einschließlich und ohne Einschränkung der Rechte, die Software zu
verwenden, zu kopieren, zu modifizieren, zusammenzuführen, zu veröffentlichen, zu vertreiben,
zu unterlizenzieren und/oder zu verkaufen, und Personen, denen die Software zur Verfügung
gestellt wird, diese Rechte zu gewähren, unter den folgenden Bedingungen:
.LP
Der obige Urheberrechtsvermerk und dieser Erlaubnisvermerk sind in allen Kopien oder
wesentlichen Teilen der Software beizulegen.
.LP
DIE SOFTWARE WIRD OHNE JEDE AUSDRÜCKLICHE ODER IMPLIZIERTE GARANTIE BEREITGESTELLT,
EINSCHLIESSLICH ABER NICHT BESCHRÄNKT AUF DIE GARANTIEN DER MARKTREIFE, DER EIGNUNG FÜR
EINEN BESTIMMTEN ZWECK UND DER NICHTVERLETZUNG. IN KEINEM FALL SIND DIE AUTOREN ODER
URHEBERRECHTSINHABER FÜR ANSPRÜCHE, SCHÄDEN ODER ANDERE HAFTUNGEN VERANTWORTLICH, SEI ES
AUFGRUND EINES VERTRAGS, UNERLAUBTER HANDLUNG ODER ANDERWEITIG, DIE AUS ODER IM
ZUSAMMENHANG MIT DER SOFTWARE ODER DER VERWENDUNG ODER ANDEREN GESCHÄFTEN MIT DER SOFTWARE
ENTSTEHEN.
.LP
Die vollständige Lizenz ist in der Datei
.I LICENSE
im Quellverzeichnis enthalten.

.SH SIEHE AUCH
.BR cp (1),
.BR gunzip (1),
.BR gzip (1),
.BR mkdir (1),
.BR rm (1).
.BR rmdir (1),
.BR sh (1),
.BR sha256sum (1),
.BR shasum (1),
.BR sudo (8)
EOF

     exit 0
}


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Paketinformation anzeigen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
commandShowPackageInfo() {
    local info

    # Ausgabe für Anzeige mit Pager (less/more) im Terminalfenster
    if isFalse "$P_OPT_QUIET"; then
        P_OUTPUT_FORMATTED=1
        P_USE_PAGER=1
        info="$(makePackageInfo)"
        echo "$info" | usePager
    fi

    # Ausgabe für Umleitung in Datei
    if [ ! -t 1 ]; then
        P_OUTPUT_FORMATTED=0
        P_USE_PAGER=0
        info="$(makePackageInfo)"
        echo "$info"
    fi
}


## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
## Zeigt die Versions- und Copyright-Informationen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
commandShowVersionAndExit() {
    cdepShowMsg "${_CDEP_SCRIPT_NAME} v${_CDEP_SCRIPT_VERSION}" \
            "Copyright (c) 2025 Christian Dorn" \
            "Alle Rechte vorbehalten."
    exit 0
}




## ========================================================================================
## Hook-API
## ========================================================================================


## Liefert das Basisverzeichnis für die Installation.
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
cdepGetBaseTarget() {
    echo "$P_BASE_TARGET"
}


## Liefert den Wert eines Hook-Parameters, bzw. ein Default (2. Methoden-Parameter), wenn
## der Hook-Parameter nicht existiert
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
cdepGetHookParameter() {
    local key="$1"
    local default=""
    local name=""
    local result=""
    local part=""
    local rest="$P_HOOK_PARAMETERS"

    if [ $# -gt 1 ]; then
        default="$2"
    fi

    while [ -n "$rest" ]; do
        case "$rest" in
            §*=*)
                part=${rest#§}     # alles nach ?
                name=${part%%=*}    # bis '='
                if [ "$name" != "$key" ]; then
                    rest=${part#*=}  # Rest trotzdem weitergeben
                    continue
                fi

                rest=${part#*=}     # Rest nach '='
                case "$rest" in
                    \'*\') val=${rest#\'}; val=${val%%\'*}; rest=${rest#*\'} ;;
                    \"*\") val=${rest#\"}; val=${val%%\"*}; rest=${rest#*\"} ;;
                    §*)    val=${rest%%§*}; rest="?${rest#*§}" ;;
                    *)     val=$rest; rest= ;;
                esac
                if [ "$name" = "$key" ]; then
                    result=$val
                    break
                fi
                ;;
            *)
                val="$default"
                break
                ;;
        esac
    done

    printf '%s' "$result"
}


## Liefert die Projektinformation (Name + Version) als String
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
cdepGetPackageInfo() {
    local divider="${1:- }"

    if isEmpty "$CDEP_PACKAGE_NAME"; then
        CDEP_PACKAGE_NAME="tools"
    fi

    if isEmpty "$CDEP_PACKAGE_VERSION"; then
        echo "$CDEP_PACKAGE_NAME"
    else
        echo "${CDEP_PACKAGE_NAME}${divider}${CDEP_PACKAGE_VERSION}"
    fi
}


## Führt (Datei-)Befehle sicher aus und verwendet 'sudo' wenn nötig und beim Skriptstart
## erfolgreich aktiviert. Gibt bei Fehlern automatisch eine Fehlermeldung aus. Die Methode
## beendet bei einem Fehler nicht(!) automatisch das Skript, sondern gibt einen Returncode
## ungleich 0 zurück.
## Optional kann im letzten Parameter eine Meldung übergeben werden, die angezeigt wird,
## wenn die Anweisung erfolgreich ausgeführt wurde. Dieser Parameter muss mit der Zeichen-
## folge 'MSG:' beginnen.
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
cdepSafeRun() {
    local args=("$@")
    local msg=""
    local output
    local status=0

    # Optional: Den letzten Parameter als Meldung verwenden, wenn er mit 'MSG:' beginnt.
    #           Anschließend den letzten Parameter entfernen.
    if [[ "${args[-1]}" == MSG:* ]]; then
        msg="${args[-1]#MSG:}"   # entfernt das Präfix
        unset 'args[-1]'         # entfernt letzten Parameter aus dem Befehl
    fi

    # Das letze Argument ist (jetzt) der Zielpfad. Falls er mit einer Tile beginnt, diese
    # durch den absoluten Pfad zum Benutzerverzeichnis ersetzen.
    local target="${args[-1]}"
    [[ "$target" == ~* ]] && target="${target/#\~/$HOME}"

    # Prüfen ob die sudo-Anmeldung noch gültig ist; ein erneutes Login aber nur durchführen,
    # wenn beim Start des Skriptes schon eine Anmeldung erfolgreich war
    if [[ "$P_USE_SUDO" == "sudo" ]] && ! sudo -n true; then
        cdepShowMsg "   Die Administratorrechte sind abgelaufen. Bitte melden Sie sich erneut an."
        sudoLogin
    fi

    # Befehl ausführen; dazu das Abbruchkriterium -e (abbrechen, wenn Returncode ≠ 0)
    # kurzzeitig außer Kraft setzen, damit bei einem Fehler die nachfolgenden Dateien
    # noch verarbeitet werden; für nicht verarbeitete Dateien wird eine Fehlermeldung
    # ausgegeben
    if isFalse "$P_OPT_DRYRUN"; then
        set +e
        output=$($P_USE_SUDO "${args[@]}" 2>&1)
        status=$?
        set -e
    fi

    # Fehler ausgeben, falls der Befehl fehlgeschlagen ist, und den Returncode des Befehls
    # zurückgeben.
    if [ "$status" -ne 0 ]; then
        local err_msg="${output##*:}"
        cdepShowError 0 "${err_msg#"${err_msg%%[! ]*}"}"
        return $status
    fi

    # Wenn als letzter Parameter eine Meldung übergeben wurde (s.o.), muss diese jetzt
    # ausgegeben werden
    if [[ -n "$msg" ]]; then cdepShowMsg "$msg"; fi
    return 0
}


## Fehlermeldung ausgeben; Skript beenden, wenn Fehlercode <> 0
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
cdepShowError() {
    local err_code="$1"
    shift  # entferne den ersten Parameter (Fehlercode) aus "$@"

    # Fehlercounter anpassen; hat in Sub-Shells keine Auswirkung
    # auf die Haupt-Shell
    P_COUNT_ERR=$((P_COUNT_ERR + 1))

    if isFalse $P_OPT_QUIET; then
        # Alle übrigen Parameter als separate Zeilen ausgeben
        showTitle

        # Ausgabe im Terminal
        local line="$1"
        shift

        case "$line" in
            "!!!! "*)
                printf "%s" "$line" ;;
            *)
                # Ausgabe in Datei/Umleitung
                printf "!!!! %s\n" "$line"
                if [ $# -gt 0 ]; then
                    printf "  !! %s\n" "$@"
                fi ;;
        esac
    fi


    # Skript beenden, wenn wir in der Haupt-Shell sind und der Fehlercode ≠ 0 ist;
    # in jedem anderen Fall einfach den Fehlercode zurückgeben
    if [ "$err_code" -ne 0 ] && [ "${BASH_SUBSHELL:=0}" -eq 0 ]; then
        quit "$err_code"
    else
        return "$err_code"
    fi
}


## Eine Meldung ausgeben
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
cdepShowMsg() {
    if isFalse $P_OPT_QUIET; then
        printf "%b\n" "$@"
    fi
}


## Warnmeldung ausgeben
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
cdepShowWarning() {
    P_COUNT_WRN=$((P_COUNT_WRN + 1))

    if isFalse $P_OPT_QUIET; then
        # Alle Parameter als separate Zeilen ausgeben
        showTitle

        # Ausgabe im Terminal
        local line="$1"
        shift

        printf "???? %s\n" "$line"
        printf "  ?? %s\n" "$@"
    fi
}




## ========================================================================================
## Hilfsmethoden
## ========================================================================================


## Relativen Pfad absolut ausgeben
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
absPath() {
    echo "$(cd "$(dirname -- "$1")" && pwd)/$(basename -- "$1")"
}


## Stellt sicher, dass eine Option für die gewählte Aktion $P_ACTION erlaubt ist.
## Die Option wird als erster Parameter an die Methode übergeben, die
## erlaubte(n) Aktion(en) folgen danach.
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
assertAction() {
    local option="$1"
    shift
    local allowed=("$@")
    for a in "${allowed[@]}"; do
        [[ "$P_ACTION" == "$a" ]] && return 0
    done

    cdepShowError 0 "Die Option '${option}' ist nur in Zusammenhang mit der/den Aktion(en) erlaubt:" \
                "    ${allowed[*]}" \
                "Die gewählte Aktion ist aber '$P_ACTION'."
    echo
    showSyntaxAndExit
}


## Prüfen ob eine Variable bereits einen Wert enthält
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
assertIsEmpty() {
    local parname="$1"
    local value="$2"

    if [[ -n "$value" ]]; then
        cdepShowError 0 "Der Parameter '$parname' wurde bereits übergeben." ""
        showSyntaxAndExit
    fi
}


## Prüfen ob die übergebene Variable einen Wert ungleich 1 hat (false)
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
assertIsFalse() {
    local parname="$1"
    local value="$2"

    if [[ "$value" -eq 1 ]]; then
        cdepShowError 0 "Der Parameter ''$parname' wurde bereits übergeben." ""
        showSyntaxAndExit
    fi
}


## Prüfen ob ein Verzeichnis die Mindestanforderungen für ein
## Installationspaket erfüllt
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
checkPackage() {
    local package="$P_PACKAGE"
    local package_input="$P_PACKAGE_INPUT"


    if [[ ! -e "$package" ]]; then
        cdepShowError 1 "Das Paket wurde nicht gefunden:" \
                    "$(absPath "$package_input")"
    elif [[ ! -d "$package" ]]; then
        cdepShowError 1 "Das ist kein Verzeichnis:" \
                    "$(absPath "$package_input")"
    fi

    local src=""

    # a) cdeploy.conf vorhanden?
    src="$package/cdeploy.conf"
    [[ -f "$src" ]] && return 0

    # b) nicht leeres ./bin?
    src="$package/bin"
    [[ -d "$src" && $(find "$src" -maxdepth 1 -type f | wc -l) -gt 0 ]] && return 0

    # c) nicht leeres ./lib?
    src="$package/lib"
    [[ -d "$src" && $(find "$src" -maxdepth 1 -type f | wc -l) -gt 0 ]] && return 0

    # d) nicht leeres ./etc?
    src="$package/etc"
    [[ -d "$src" && $(find "$src" -maxdepth 1 -type f | wc -l) -gt 0 ]] && return 0

    # e) nicht leeres ./man?
    src="$package/man"
    [[ -d "$src" && $(find "$src" -maxdepth 1 -type f | wc -l) -gt 0 ]] && return 0

    # f) ./files mit files.conf und mindestens einer weiteren Datei?
    src="$package/files"
    if [[ -d "$src" && -f "$src/files.conf" ]]; then
        local num_files;  num_files=$(find "$src" -maxdepth 1 -type f | wc -l)
        (( num_files > 1 )) && return 0
    fi

    # An dieser Stelle haben wir sichergestellt, dass das Verzeichnis nicht den
    # Mindestanforderungen für ein Intallationspaket erfüllt
    cdepShowError 1 "Das ist kein Installationspaket:" \
                "$(absPath "$package")" \
                "Siehe 'cdeploy help' für mehr Informationen."
    return $?
}


## Zugriffsrechte (Schreibrechte) für übergebenes Objekt prüfen; wenn nötig, sudo-Kennwort
## abfragen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
checkPermissions() {
    # Wenn die Installation global erfolgt, prüfen wir zuerst die Ordner ./bin, ./etc,
    # ./lib und ./man. Wenn in einem dieser Verzeichnisse Dateien sind, Kennwort abfragen
    # und Prüfung beenden.
    if [[ $P_OPT_SCOPE == "global" ]]; then
        for d in "$P_TARGET_BIN" "$P_TARGET_LIB" "$P_TARGET_ETC" "$P_TARGET_MAN"; do
            if ! dirIsEmpty "$d"; then
                sudoLogin
                return 0
            fi
        done
    fi

    # Wenn in der ersten Prüfung kein sudo-Kennwort notwendig war, müssen jetzt die
    # Einträge in der Datei 'files.conf' geprüft werden. Sobald eines der Verzeichnisse
    # sudo benötigt, Kennwort abfragen und Prüfung beenden.
    if [[ $P_USE_SUDO == "" ]]; then
        local files_conf="${P_PACKAGE}/files.conf"

        # Wenn files.conf nicht existiert -> kein sudo nötig
        [[ -f "$files_conf" ]] || return 0

        # 2.2 Alle Zielpfade auslesen
        while IFS= read -r line; do
            # Leerzeilen und Kommentare überspringen
            [[ -z "$line" || "$line" =~ ^# ]] && continue

            # Quelle und Ziel trennen (z. B. "foo.txt   /usr/bin")
            local src dest
            read -r src dest <<<"$line"

            # Wenn kein Ziel angegeben -> überspringen
            [[ -z "$dest" ]] && continue

            # Prüfen, ob Zielverzeichnis Schreibrechte erfordert
            local target_dir
            target_dir=$(dirname "$dest")

            if [[ ! -w "$target_dir" ]]; then
                sudoLogin
                return 0
            fi
        done < "$files_conf"
    fi
}


## Datei(en) in Verzeichnis $2 nach $3 kopieren
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
copyFiles() {
    local category="$1"
    local src_dir="$2"
    local dest_dir="$3"

    if [ -d "$src_dir" ]; then
        shopt -s nullglob
        cdepSafeRun mkdir -p "$dest_dir"

        for f in "$src_dir"/*; do
            [ -f "$f" ] || continue
            if cdepSafeRun cp -u "$f" "$dest_dir/"; then
                cdepSafeRun chmod 755 "$dest_dir/$(basename "$f")" \
                    "MSG:  -> $dest_dir/$(basename "$f")"
                manifestAppend "$dest_dir/$(basename "$f")" "$category"
                P_COUNT_CPY=$((P_COUNT_CPY + 1))
            fi
        done
        shopt -u nullglob
    fi
}


## Prüfen ob ein Verzeichnis leer ist
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
dirIsEmpty() {
    local path="$1"

    # Wenn Pfad nicht existiert -> prüfe Elternverzeichnis
    if [[ ! -e "$path" ]]; then
        path=$(dirname "$path")
    fi

    # Wenn keine Directory -> false
    if [[ ! -d "$path" ]]; then
        return 1
    fi

    # Wenn Verzeichnis nicht leer -> false
    if [[ $(find "$path" -mindepth 1 -maxdepth 1 2>/dev/null | wc -l) -gt 0 ]]; then
        return 1
    fi

    # Leeres Verzeichnis -> true
    return 0
}


## Lädt die angegebene Datei, wenn der Quellpfad eine URL ist. Liefert
## den Pfad zur heruntergeladenen Datei oder den orignalen Quellpfad,
## wenn dieser keine URL darstellt.
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
downloadIfURL() {
    local pack_url="$1"

    if [[ "$pack_url" =~ ^(https?|ftp|file):// ]]; then
        showTitle

        # Wir erwarten immer ein cdeploy-Archiv
        if [[ ! "$pack_url" =~ ${_CDEP_PACK_EXT_RE}$ ]]; then
           cdepShowError 1 "Die angegebene Quelle ist kein ${_CDEP_PACK_EXT}-Archiv."
           return $?
        fi
        cdepShowMsg "Lade Installationspaket von URL" \
                "${pack_url}..." \
                ""

        # temporäre Datei oder Verzeichnis
        local tmpfile;  tmpfile=$(mktemp "/tmp/cdeploy_pkg.XXXXXX${_CDEP_PACK_EXT}") || \
                cdepShowError 1 "Temporäre Datei konnte nicht angelegt werden."; return $?
        cdepSafeRun curl -fsSL "$pack_url" -o "$tmpfile" || \
                cdepShowError 1 "Download fehlgeschlagen."; return $?
        P_TMP_OBJECTS+=("$tmpfile")

        # Pfad zur temporären Datei zurückgeben
        pack_url="$tmpfile"
    fi

    # Pfad prüfen und zurückgeben
    printf '%s' "$pack_url"
    return 0
}


## Sicherstellen, dass der übergebene Pfad existiert und in der Umgebungsvariablen
## vorhanden ist. Die Methode akzeptiert keine Pfade, die Doppelpunkte (:) enthalten,
## da Doppelpunkte in PATH und MANPATH eine besondere Bedeutung als Trennzeichen
## haben. Außerdem wird sichergestellt, dass MANPATH immer mindestens den Standardpfad
## für Man-Pages enthält.
##
## Die Pfadvariablen werden erweitert, indem der neue Pfad ANGEHÄNGT wird, nicht, wie viele
## Programme es machen, vorangestellt. Die Pfade in den Umgebungsvariablen werden von vorne
## nach hinten durchsucht, und die erste gefundene Datei wird verwendet. Würde $target an
## den Anfang gestellt, könnten – unabsichtlich oder absichtlich – Systemprogramme oder
## Dateien verdeckt werden.
##
## Die Erweiterungen von PATH und MANPATH werden in ~/.profile eingetragen, da diese
## von (den meisten) Shells ausgewertet wird.
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
ensureLocalPath() {
    local varname="$1"
    local target="$2"
    local profile="$HOME/.profile"

    # Doppelpunkte sind in PATH-ähnlichen Variablen verboten. Wenn das Ziel Doppelpunkte
    # enthält, wird das Skript mit einer Fehlermdelung abgebrochen.
    # Wenn der Pfad ok ist, wird er angelegt, falls er noch nicht existiert.
    [[ "$target" == *:* ]] && cdepShowError 1 "Pfade mit Doppelpunkt (':') werden nicht unterstützt."
    [ -d "$target" ] || cdepSafeRun mkdir -p "$target"

    # Aktuellen Wert der Umgebungsvariablen ermitteln, falls vorhanden
    local current_value=""
    if [[ -n ${!varname-} ]]; then
        current_value="${!varname}"
    fi

    # Falls MANPATH leer ist, den System-Standard verwenden. Dadurch kann MANPATH niemals
    # leer sein. Das ist wichtig, weil 'man' keinen Fallback besitzt, und bei leerem
    # MANPATH somit überhaupt keine Man-Pages mehr gefunden würden.
    if [[ "$varname" == "MANPATH" && -z "$current_value" ]]; then
        current_value=$(man --path 2>/dev/null)
    fi

    # Wenn $target bereits in der Umgebungsvariablen vorhanden ist, kann die Methode an
    # dieser Stelle beendet werden.
    case ":$current_value:" in
        *":$target:"* | *":$target" | "$target:"* | "$target") return 0 ;;
    esac

    # Neue Pfadeinstellung in der aktiven Shell aktivieren
    [[ -n "$current_value" ]] && current_value="$current_value:$target" || current_value="$target"
    eval "export $varname=\"\$$current_value:$target\""

    # Den erweiterten Pfad in ~/.profile eintragen, wenn er dort noch nicht vorhanden ist.
    # Der Eintrag wird eindeutig markiert.
    if [ "$P_OPT_DRYRUN" -eq 0 ] && \
        ! grep -Eq "^export[[:space:]]+$varname=.*(^|:)$target(:|$)" "$profile" 2>/dev/null; then
        # Start der Änderung in ~/.profile markieren; das Ende wird beim Beenden des
        # Skriptes geschrieben.
        if isFalse "$P_ENV_PATH_SET"; then
            {
                echo ""
                echo "# >>> cdeploy initialize >>>"
                echo "# Setting path(s) for cdeploy"
                P_ENV_PATH_SET=1
            } >> "$profile"
        fi

        # Die Pfadanpassung für PATH und MANPATH muss unterschiedlich sein
        # shellcheck disable=SC2016
        case "$varname" in
            PATH)
                echo "export $varname=\"\$$varname:$target\"" >> "$profile" ;;
            MANPATH)
# Zur Erinnerung: muss linksbündig stehen, weil Here-Doc
cat <<EOF >> ~/.profile
if [[ -z "\$MANPATH" ]]; then
    MANPATH="\$(man --path 2>/dev/null || echo \"$P_TARGET_MAN\")"
fi
export MANPATH="\$MANPATH:$P_TARGET_MAN"
EOF
        esac

        eval "export $varname=\"\$$varname:$target\""

        # Rückmeldung an den Benutzer
        case $- in
            *i*)  . "$profile" && cdepShowMsg "  -> \$$varname wurde aktualisiert." ;;
            *)    cdepShowMsg "  -> \$$varname wurde angepasst. Bitte das Terminal neu starten." "" ;;
        esac
    fi
}


## Installationspaket für (De-)Installation in ein temporäres Verzeichnis entpacken
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
extractPackage() {
    local archive="$1"
    if [[ "$archive" == "" || "$archive" != *"$_CDEP_PACK_EXT" ]]; then
        printf '%s' "$archive"
        return 0
    fi

    local tmpdir;  tmpdir=$(mktemp -d) || {
        cdepShowError 1 "Temporäres Verzeichnis konnte nicht angelegt werden."; return $?
    }

    # temporäres Objekt für das spätere Aufräumen merken
    P_TMP_OBJECTS+=("$tmpdir")

    tar -xf "$archive" -C "$tmpdir" || {
        cdepShowError 1 "Archiv konnte nicht extrahiert werden."; return $?
    }

    printf '%s' "$tmpdir"  # $tmpdir zurückgeben
    return 0
}


## Daten an eine Datei anhängen. Die Datei wird bei Bedarf automatisch
## erzeugt, und falls nötig wird eine sudo-Berechtigung abgefragt und
## angewandt.
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
fileAppend() {
    local datei="$1"
    shift || return 1

    local status=0

    # +e erlaubt Fehlerhandling ohne Skriptabbruch
    set +e
    # Alle Zeilen gesammelt anhängen; anstatt 'printf "%b"' werden die Tabs gezielt per
    # 'sed' expandiert. Das minimiert die Gefahr durch eingeschleuste Escape-Sequenzen,
    # die von 'printf "%b"' interpretiert würden.
    #printf "%s\n" "$@" | $P_USE_SUDO tee -a "$datei" >/dev/null
    for arg in "$@"; do
        printf "%s\n" "$(printf "%s" "$arg" | sed 's/\\t/\t/g')" | \
                $P_USE_SUDO tee -a "$datei" >/dev/null
    done
    status=$?
    set -e

    if (( status != 0 )); then
        cdepShowError 1 "Manifest kann nicht geschrieben werden: $datei"
    fi

    return $status
}


## Aufräumen beim Beenden oder Abbrechen des Skriptes
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
finalCleanup() {
    # Zuerst alle Traps entfernen, um Rekursionen zu vermeiden
    trap - EXIT INT TERM HUP

    # Offenen Eintrag in ~/.profile abschließen
    if isFalse "$P_OPT_DRYRUN" && isTrue "$P_ENV_PATH_SET"; then
        echo "# <<< cdeploy initialize <<<" >> "$HOME/.profile"
    fi

    # Temporäre Dateien/Verzeichnisse entfernen
    for p in "${P_TMP_OBJECTS[@]}"; do
        [[ -e $p ]] && cdepSafeRun rm -rf -- "$p"
    done

    # Verwendung von sudo deaktivieren
    P_USE_SUDO=""
}


## Freies Kopieren von Dateien und Verzeichnissen im ./files Verzeichnis
## des Installationspakets. Das Ziel für diese Objekte muss in der
## Datei ./files/files.conf definiert werden.
## Beispiel:
##     foo.txt ~/Dokumente
##     bar.txt ~/Dokumente/
##     summary ~/Dokumente/digest.txt
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
freeCopy() {
    local def_file="$1"  # Konfigurationsdatei für das Kopieren
    local src_base="$2"  # Quellverzeichnis im Paket
    local output status
    local src dest
    local src_path dest_path

    [ -f "$def_file" ] || \
        { cdepShowWarning "Keine Konfigurationsdatei für das Kopieren gefunden."; return; }

    set +e
    while IFS=$'\t ' read -r src dest || [ -n "$src" ]; do
        # Kommentare und leere Zeilen überspringen
        [[ -z "$src" || "$src" =~ ^# ]] && continue

        # Quell- und Zielpfad einstellen
        src_path="$src_base/$src"
        dest_path="$dest"

        if [ ! -e "$src_path" ]; then
            cdepShowWarning "Die Quelldatei existiert nicht." \
                        "$src_path"
            continue
        elif [ -d "$src_path" ]; then
            cdepShowWarning "Es werden keine Verzeichnisse kopiert!" \
                        "Mehr Informationen finden Sie hier: 'cdeploy --help'." \
                        "$src_path"
            continue
        fi

        # Zielverzeichnis erstellen; wenn eine Tile am Anfang des Zielpfades steht,
        # ersetze sie durch den absoluten Pfad zum Benutzerverzeichnis
        [[ "$dest_path" == ~* ]] && dest_path="${dest_path/#\~/$HOME}"
        if [ ! -e "$dest_path" ]; then
            if [[ "$dest_path" == */ ]]; then
                cdepSafeRun mkdir -p "$dest_path"
            else
                cdepSafeRun mkdir -p "$(dirname "$dest_path")"
            fi
        fi

        # Datei aus dem Paket in das Ziel kopieren
        if [ -d "$dest_path" ] || [[ "$dest_path" == */ ]]; then
            # $dest_path ist ein Verzeichnis
            if cdepSafeRun cp -uT "$src_path" "$dest_path" \
                 "MSG:  -> V $src -> $dest_path"; then
                manifestAppend "$dest_path" "files"
                P_COUNT_CPY=$((P_COUNT_CPY + 1))
            fi
        else
            # $dest_path ist eine Datei
            if cdepSafeRun cp -u "$src_path" "$dest_path" \
                 "MSG:  -> D $src -> $dest_path"; then
                manifestAppend "$dest_path" "files"
                P_COUNT_CPY=$((P_COUNT_CPY + 1))
            fi
        fi
    done < "$def_file"
    set -e
}


## Liefere den sha256 Hash für eine Datei/ein Verzeichnis
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
getFileHash() {
    local filepath="$1"

    # Datei/Verzeichnis nicht gefunden oder nicht übergeben
    #if [ ! -f "$filepath" ]; then
    if [ ! -f "$filepath" ] && [ ! -d "$filepath" ]; then
        echo "n/a"
        return 1
    fi

    # sha256-Hash berechnen
    if command -v sha256sum >/dev/null 2>&1; then
        if [ -d "$filepath" ]; then
            ( cd "$filepath" && find . -type f -exec sha256sum {} + | sort | \
                    sha256sum | awk '{print $1}' )
        else
            sha256sum "$filepath" | awk '{print $1}'
        fi
        return 0
    elif command -v shasum >/dev/null 2>&1; then
        if [ -d "$filepath" ]; then
            ( cd "$filepath" && find . -type f -exec shasum -a 256 {} + | sort | \
                    shasum -a 256 | awk '{print $1}' )
            else
                shasum -a 256 "$filepath" | awk '{print $1}'
            fi
        return 0
    fi

    # kein SHA-Tool verfügbar
    echo "n/a"
    return 2
}


## Zielverzeichnisse für (De-)Installation ermitteln und an die
## globalen Variablen übertragen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
getInstallerTargets() {
    # Zielverzeichnisse ermitteln
    case "$P_OPT_SCOPE" in
        global)
            P_BASE_TARGET="${CDEP_BASE_GLOBAL}/${CDEP_PACKAGE_NAME}"
            P_TARGET_MAN="/usr/share/man"
            P_TARGET_SYM="/usr/local/bin"
            ;;
        local)
            P_BASE_TARGET="${CDEP_BASE_LOCAL}/${CDEP_PACKAGE_NAME}"
            P_TARGET_MAN="$HOME/.local/share/man"
            P_TARGET_SYM="$HOME/.local/bin"
            ;;
        *)
            cdepShowError 1 "Unbekannter Zielbereich, oder Zielbereich nicht definiert: '$P_OPT_SCOPE'"
            ;;
    esac

    P_TARGET_BIN="${P_BASE_TARGET}/bin"
    P_TARGET_LIB="${P_BASE_TARGET}/lib"
    P_TARGET_ETC="${P_BASE_TARGET}/etc"
    P_TARGET_MANIFEST="$(getCdeployDir $P_OPT_SCOPE)/manifests"
    P_TARGET_HOOKS="$(getCdeployDir $P_OPT_SCOPE)/hooks"

    for var in CDEP_PACKAGE_NAME P_BASE_TARGET P_TARGET_BIN P_TARGET_ETC P_TARGET_LIB P_TARGET_MAN \
                P_TARGET_MANIFEST P_TARGET_SYM; do
        validateVar "$var"
    done
}


## Liefert den Pfad zum lokalen/globalen Manifest-Verzeichnis
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
getCdeployDir() {
    case "$1" in
        global) echo "/usr/local/share/${_CDEP_SCRIPT_NAME}" ;;    # Pfad zurückgeben
        local)  echo "$HOME/.local/share/${_CDEP_SCRIPT_NAME}" ;;  # Pfad zurückgeben
        *)      cdepShowError 1 "Illegaler Zielbereich: $1" ;;
    esac
}


## Manifestdatei(en) ermitteln. Übergeben werden darf sowohl ein eindeutiger Name, als auch
## ein Glob, um mehrere Dateien aufeinmal zu suchen.
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
getManifestContent() {
    # Parameter:
    #   $1 = Paketbasisname (z. B. "mypkg" oder "mypkg-*")
    #   $2 = Scope ("local" oder "global")
    local manifest_name="$1"
    local scope="$2"
    local manifest_path file files_found=0

    # Scope-Text für Fehlermeldungen
    local scope_str
    case "$scope" in
        global) scope_str="global" ;;
        local)  scope_str="lokal" ;;
        *)
            cdepShowError 1 "Unbekannter Zielbereich: $scope"
            return $? ;;
    esac

    # Basispfad abrufen
    manifest_path="$(getCdeployDir "$scope")/manifests" || {
        cdepShowError 1 "Es wurde keine ${scope_str}e Installation gefunden."
        return $?
    }

    # Übergebene Datei(en) einlesen
    local file

    if [ "${manifest_name##*.}" = "manifest" ]; then
        # Exakte Datei auslesen
        file="$manifest_path/$manifest_name"
        if [ -f "$file" ]; then
            readManifestFile "$file"
            files_found=1
        fi
    else
        # Alle passenden Versionen
        for file in "$manifest_path"/"${manifest_name}"*.manifest; do
            [ -f "$file" ] || continue
            readManifestFile "$file"
            files_found=1
        done
    fi

    # Wenn keine Datei gefunden wurde -> Fehler
    if [ "$files_found" -eq 0 ]; then
        cdepShowError 1 "Es wurde keine ${scope_str}e Installation von '$manifest_name' gefunden."
        return $?
    fi

    return 0
}


## Liefert einen String zur Anzeige des Zielbereichs (Scope)
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
getScopeStr() {
    if [[ "$P_OPT_SCOPE" == "global" ]]; then
        echo "global"
    else
        echo "lokal"
    fi
}


## Installieren der Man-Pages aus dem Installationspaket
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
installManpages() {
    local src_dir="$1"
    local dest_dir="$P_TARGET_MAN"
    local target_dir

    if [ -d "$src_dir" ]; then
        # Kopiere die Dateien aus dem Paket an den Zielort; passe die Zugriffsrechte
        # an (644); wandle die kopierte Man-Page in eine .gz-Datei, wenn möglich;
        # trage die fertige Datei ins Manifest ein
        for manfile in "$src_dir"/*.[1-9]; do
            [ -f "$manfile" ] || continue
            section="${manfile##*.}"
            target_dir="$dest_dir/man$section"
            cdepSafeRun mkdir -p "$target_dir"
            if cdepSafeRun cp -u "$manfile" "$target_dir/" \
                 "MSG:  -> $target_dir/$(basename "$manfile").gz"; then
                cdepSafeRun chmod 644 "$target_dir/$(basename "$manfile")"
                P_COUNT_CPY=$((P_COUNT_CPY + 1))
                if cdepSafeRun gzip -f "$target_dir/$(basename "$manfile")"; then
                    manifestAppend "$target_dir/$(basename "$manfile".gz)" "man"
                else
                    manifestAppend "$target_dir/$(basename "$manfile"*)" "man"
                fi
            fi
        done

        # Man-Datenbank aktualisieren
        if [ "$P_OPT_SCOPE" = "global" ]; then
            cdepShowMsg "  => Aktualisiere globale Man-Datenbank..."
            if ! $P_USE_SUDO mandb -q; then
                cdepShowWarning "Die globale Man-Datenbank konnte nicht aktualisiert werden."
            fi
        else
            cdepShowMsg "  => Aktualisiere lokale Man-Datenbank..."
            if ! mandb -q -u; then
                cdepShowWarning "Die lokale Man-Datenbank konnte nicht aktualisiert werden."
            fi
        fi
    fi
}


## Prüfen ob eine Variable leer ist
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
isEmpty() {
    if [ -z "$1" ] || [ "$1" == "" ]; then
        return 0
    fi
    return 1
}


## Behandelt die übergebene Variable als Boolean und gibt 0 zurück, wenn diese leer oder
## '0' ist, ansonsten 1
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
isFalse() {
    case "$1" in
        ""|0) return 0 ;;
        *)    return 1 ;;
    esac
}


## Prüfen ob ein Hook überschrieben wurde (also tatsächlich Code enthält)
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
isOverridden() {
    local name="$1"
    local def

    # declare -f liefert die komplette Funktionsdefinition (oder nichts)
    if ! def=$(declare -f "$name" 2>/dev/null); then
        return 1  # Funktion existiert nicht -> nicht überschrieben
    fi
    # Wenn der Marker in der Definition vorkommt -> Default noch aktiv
    if printf '%s\n' "$def" | grep -q '__DEFAULT_HOOK__'; then
        return 1   # nicht überschrieben
    else
        return 0   # überschrieben
    fi
}


## Behandelt die übergebene Variable als Boolean; kehrt den Rückgabewert von 'isFalse' um.
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
isTrue() {
    isFalse "$1"; return $((1 - $?))
}


## Konfigurationsdatei einbinden
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
loadConfigFile() {
    local config_file="$1"

    if [[ -f "$config_file" ]]; then
        if ! "$_CDEP_SHELL_BIN" -n "$config_file" 2>/dev/null; then
            cdepShowError 1 "Die Konfigurationsdatei hat ein ungültiges Format." "$config_file"
        fi
        # shellcheck disable=SC1090
        . "$config_file"
    fi
}


## Lädt die bei der Installation gespeicherten Remove-Hooks
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
loadRemoveHooks() {
    # Abbrechen, wenn die Datei nicht existiert
    local hook_path;  hook_path="$(getCdeployDir "$P_OPT_SCOPE")/hooks/${P_PACKAGE}.hook"
    [ ! -f "$hook_path" ] && hook_path="${hook_path}.gz"
    if [ ! -f "$hook_path" ]; then return 0; fi

    local hsh;  hsh="$(getFileHash "$hook_path")"
    if [ "$hsh" != "$1" ]; then
        cdepShowError 1 "Die gespeicherten Paketinformationen wurden anscheinend manipuliert" \
                    "und können deshalb nicht verwendet werden!"
    fi

    # Hook-Datei laden; die Datei kann sowohl gepackt als .gz vorliegen,
    # als auch ungepackt als .hook
    case "$hook_path" in
        *.gz)
            local tmpfile;  tmpfile="$(mktemp "/tmp/${P_PACKAGE}.XXXXXX")" || \
                                cdepShowError 1 "Konnte temporäre Datei für Hook nicht erstellen."
            P_TMP_OBJECTS+=("$tmpfile")
            #if cdepSafeRun gunzip -c "${hook_path}" > "$tmpfile"; then
            if gunzip -c "$hook_path" > "$tmpfile"; then
                loadConfigFile "$tmpfile"
            else
                cdepShowError 1 "Die Paketinformationen konnten nicht gelesen werden."
            fi
            ;;
        *)
            loadConfigFile "$hook_path"
            ;;
    esac
}


## Erstellt einen Key-Value-Eintrag für eine Konfigurationsdatei.
## Wenn die übergebene Variable leer ist, wird der Eintrag als Kommentar
## angelegt, ansonsten als aktive Zeile.
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
makeConfigLine() {
    local varname="$1"
    local value="$2"
    if [[ -n "$value" ]]; then
        echo "${varname}=\"${value}\""
    else
        echo "#${varname}=\"\""
    fi
}


## Erstellt die Paketinformationen zur Anzeige im Terminal und/oder Ausgabe in Datei
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
makePackageInfo() {
    local output

    output="$(
        local _lw=80;  readonly _lw

        # Titel und Beschreibung der Aktion ausgeben
        showTitle

        cdepShowMsg "Informationen zu Paket aus Quelle" \
                "$(absPath "$P_PACKAGE_INPUT")" \
                "" \
                ""

        # Prüfen ob das Paket existiert
        if [[ ! -e "$P_PACKAGE" ]]; then
            cdepShowError 1 "Das angegebene Paket wurde nicht gefunden."
            return 0
        fi

        # Hinweis ausgeben, wenn das Paket Hooks definiert
        if usesHooks; then
            cdepShowMsg \
                "   ================================================================================" \
                "    DIESES PAKET ENTHÄLT SKRIPTERWEITERUNGEN DES ANBIETERS, DIE DIE FUNKTIONALITÄT" \
                "    VON CDEPLOY ERWEITERN. DIES IST KEIN FEHLER, STELLT ABER EIN POTENTIELLES" \
                "    SICHERHEITSRISIKO DAR, DA SO AUCH SCHADHAFTER CODE AUSGEFÜHRT WERDEN KÖNNTE." \
                "" \
                "    VERWENDEN SIE DAS PAKET DAHER NUR, WENN SIE ES VON EINER VERTRAUENSWÜRDIGEN" \
                "    QUELLE ERHALTEN HABEN!" \
                "   ================================================================================" \
                "" \
                ""
        fi

        # Zur Erinnerung: Der Variablenname 'hash' kollidiert hier mit dem eingebauten Bash
        #                 Befehl gleichen Namens! Daher 'hsh' verwenden.
        local hsh;  hsh="$(getFileHash "$P_PACKAGE_SOURCE")"
        case $? in
            1) hsh="${hsh} (Paket nicht gefunden)" ;;
            2) hsh="${hsh} (kein SHA-Tool gefunden)" ;;
        esac

        cdepShowMsg "Paketinformation" \
            "================" \
            "Name.................: ${CDEP_PACKAGE_NAME:-./.}" \
            "Version..............: ${CDEP_PACKAGE_VERSION:-./.}" \
            "Ersteller............: ${CDEP_PACKAGE_CREATOR:-./.}" \
            "Quelle/URL...........: ${CDEP_PACKAGE_URL:-./.}" \
            "Hash.................: $hsh" \
            "Copyright............: ${CDEP_PACKAGE_COPYRIGHT:-./.}"

        cdepShowMsg "" \
            "Installationspfade:" \
            "    Lokal............: ${CDEP_BASE_LOCAL:-./.}" \
            "    Global...........: ${CDEP_BASE_GLOBAL:-./.}"

        cdepShowMsg "" \
            "Beschreibung:" \
            "${CDEP_PACKAGE_DESCRIPTION:-./.}" | fold -s -w "$_lw"


        # Hier aufhören für die einfache Ausgabe
        if isFalse "$P_OPT_VERBOSE"; then return 0; fi


        # Erweiterte Ausgabe inkl. aller Dateien
        local total=0

        cdepShowMsg "" \
            "" \
            "Dateien im Paket" \
            "================"

        # ./bin, ./lib, ./etc, ./man
        for dir in bin lib etc man; do
            if [[ -d "${P_PACKAGE}/$dir" ]]; then
                cdepShowMsg "./$dir"
                while IFS= read -r f; do
                    cdepShowMsg "    $f"
                    total=$((total + 1))
                done < <(ls -1 "${P_PACKAGE}/$dir")
                cdepShowMsg ""
            fi
        done

        # --- files ---
        local files_dir="${P_PACKAGE}/files"
        local files_conf="$files_dir/files.conf"

        if [[ -d "$files_dir" && -f "$files_conf" ]]; then
            cdepShowMsg "files/  (gruppiert nach Ziel)"

            # Kommentare und Leerzeilen überspringen, sortieren, zählen
            mapfile -t lines < <(grep -Ev '^\s*#|^\s*$' "$files_conf" | sort -k2,2 -k1,1)

            local last_target=""
            local filecount=0

            for line in "${lines[@]}"; do
                src=${line%%[[:space:]]*}
                target=${line#*[[:space:]]}

                # Verzeichnisanteil extrahieren:
                if [[ "$target" == */ ]]; then
                    # endet auf / -> ist ein Verzeichnis
                    target="${target%/}"
                elif [[ "$target" == *"/"* ]]; then
                    # enthält / -> alles vor letztem /
                    src="${target##*/}"
                    target="${target%/*}"
                else
                    # kein / -> aktuelles Verzeichnis
                    target="."
                fi

                if [[ "$target" != "$last_target" ]]; then
                    cdepShowMsg "    $target/"
                    last_target=$target
                fi
                cdepShowMsg "        $src"
                filecount=$((filecount + 1))
            done

            total=$(( total + filecount ))
            cdepShowMsg ""
        fi

        cdepShowMsg "" "Es befinden sich insgesamt $total Datei(en) im Paket."
        )"


    # Die erstellten Informationen zurückgeben
    echo "$output"
}


## Erstellt die Paketinformationen zur Anzeige im Terminal und/oder Ausgabe in Datei
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
makePackageList() {
    local output

    output="$(
    local local_manifests;   local_manifests="$(getCdeployDir local)/manifests"
    local global_manifests;  global_manifests="$(getCdeployDir global)/manifests"
    local counter=0

    # Titel und Beschreibung der Aktion ausgeben
    showTitle

    cdepShowMsg "Liste aller mit cdeploy installierten Pakete auf diesem System." \
            "" \
            ""

    cdepShowMsg "lokal"
    if [ -d "$local_manifests" ]; then
        for f in "$local_manifests"/*.manifest; do
            [ -e "$f" ] || continue   # wenn kein Manifest existiert
            cdepShowMsg "    $(basename "${f%.manifest}")"
            counter=$((counter + 1))
        done
        echo
    else
        cdepShowMsg "    (keine)"
        echo
    fi

    cdepShowMsg "global"
    if [ -d "$global_manifests" ]; then
        for f in "$global_manifests"/*.manifest; do
            [ -e "$f" ] || continue
            cdepShowMsg "    $(basename "${f%.manifest}")"
            counter=$((counter + 1))
        done
    else
        cdepShowMsg "    (keine)"
    fi


    case $counter in
        0) cdepShowMsg "" "" "Es sind keine Pakete installiert." ;;
        1) cdepShowMsg "" "" "Es ist 1 Paket installiert." ;;
        *) cdepShowMsg "" "" "Es sind insgesamt $counter Pakete installiert." ;;
    esac
    )"

    # Die erstellten Informationen zurückgeben
    echo "$output"
}


## Symlinks auf alle Objekte in 'dest_dir' erstellen, die auch in
## 'src_dir' vorhanden sind. Damit soll vermieden werden, dass die PATH
## Variable angepasst werden muss, um die kopierten Skripte global
## ausführbar zu machen.
## 'dest_dir' sollte abhängig vom Scope entweder /usr/local/bin oder
## ~/.local/bin sein.
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
makeSymlinks() {
    local src_dir="$1"
    local dest_dir="$2"
    local dest_file

    if [ -d "$src_dir" ]; then
        cdepSafeRun mkdir -p "$dest_dir"
        for f in "$src_dir"/*; do
            [ -f "$f" ] || continue
            dest_file="$dest_dir/$(basename "$f")"
            cdepSafeRun ln -sf "$f" "$dest_file" \
                 "MSG:     -> $dest_file -> $f"
            manifestAppend "$dest_file" "link"
        done
    fi
}


## Enitrag zur Manifest-Datei hinzufügen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
manifestAppend() {
    # Bei Testläufen wird kein Manifest geschrieben; abbrechen
    if [ "$P_OPT_DRYRUN" -ne 0 ]; then return 0; fi


    # Wenn nötig, Header für Manifest-Datei schreiben
    if [[ -z "$P_MANIFEST_FILE"  ]]; then manifestInit; fi

    # übergebene Dateiinformationen lesen und prüfen
    local filepath="$1"
    local category="$2"

    [ -f "$filepath" ] || return 1

    # SHA256 Hash ermitteln
    local hash;  hash="$(getFileHash "$filepath")"

    # Projektname und -version
    local pname;    pname="$CDEP_PACKAGE_NAME"
    local pversion; pversion="$(versionNormalized "$CDEP_PACKAGE_VERSION")"

    # Dateigröße und mtime ermitteln
    local size mtime
    if stat --version >/dev/null 2>&1; then
        # GNU stat (Linux)
        size=$(stat -c%s "$filepath")
        mtime=$(stat -c%Y "$filepath")
    else
        # BSD/macOS stat
        size=$(stat -f%z "$filepath")
        mtime=$(stat -f%m "$filepath")
    fi

    # Zeile ins Manifest schreiben
    fileAppend "$P_MANIFEST_FILE" "${filepath}\t${hash}\t${pname}\t${pversion}\t${P_OPT_SCOPE}\t${mtime}\t${category}\t${size}"
}


## Manifest-Datei anlegen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
manifestInit() {
    # Bei Testläufen wird kein Manifest geschrieben; abbrechen
    if [ "$P_OPT_DRYRUN" -ne 0 ]; then return 0; fi


    # Bestimmen der Manifestdatei
    cdepSafeRun mkdir -p "$P_TARGET_MANIFEST"

    P_MANIFEST_FILE="${P_TARGET_MANIFEST}/$(cdepGetPackageInfo -).manifest"
    if [ -f "$P_MANIFEST_FILE" ]; then
        cdepSafeRun rm "$P_MANIFEST_FILE"
    fi

    # Header schreiben
    local install_date;  install_date=$(date -Iseconds)

    fileAppend "$P_MANIFEST_FILE" \
        "###" \
        "# ${_CDEP_SCRIPT_NAME} v${_CDEP_SCRIPT_VERSION} – Manifest" \
        "# Projekt...........: ${CDEP_PACKAGE_NAME} v${CDEP_PACKAGE_VERSION}" \
        "# Zielbereich.......: ${P_OPT_SCOPE}" \
        "# Installationsdatum: $install_date" \
        "# Quelle/Paket......: $(absPath "$P_PACKAGE")" \
        "#" \
        "# Zielpfad\tHash_SHA256\tpname\tpversion\tscope\tmtime\tKategorie\tGröße" \
        "###" \
        ""
}


## Skript beenden
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
quit() {
    local return_code="$1"

    # Zusammenfassung zu Fehlern und Warnungen ausgeben
    if isTrue $P_SHOW_SYNOPSIS; then
        local warn_str
        [[ $P_COUNT_WRN -eq 1 ]] && warn_str="Warnung" || warn_str="Warnungen"
        cdepShowMsg "" "${P_COUNT_WRN} ${warn_str}, ${P_COUNT_ERR} Fehler"
    fi

    # Ggf. Hinweis auf Testlauf ausgeben
    if [ "$return_code" -lt 255 ] && isTrue "$P_OPT_DRYRUN"; then
        cdepShowMsg "" \
                "" \
                "     !!! ================================================================== !!!" \
                "     !!!  DIESES WAR EIN TESTLAUF. ES WURDEN KEINE ÄNDERUNGEN VORGENOMMEN.  !!!" \
                "     !!!        ES WURDEN KEINE DATEIEN HINZUGEFÜGT ODER ENTFERNT.          !!!" \
                "     !!!                ES WURDE KEIN MANIFEST GESCHRIEBEN.                 !!!" \
                "     !!! ================================================================== !!!" \
                "" \
                ""
    fi

    # Darstellung beenden
    showBottomLine

    # Skript mit übergebenen Returncode abschließen
    exit "$return_code"
}


## Liest eine Manifestdatei und schreibt sie nach stdout der aktuellen Subshell.
## Leer- und Kommentarzeilen werden ignoriert.
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
readManifestFile() {
    local ws;  ws="$(printf ' \t')"
    local tmp

    while IFS= read -r line || [ -n "$line" ]; do
        # Zeile am Anfang trimmen (Leerzeichen und Tabs entfernen), um Kommentarzeilen
        # zuverlässig zu erkennen
        tmp="${line#"${line%%[!"${ws}"]*}"}"
        case "$tmp" in
            \#*|"") continue ;;  # Kommentare/Leerzeilen überspringen
            *) printf '%s\n' "$line" ;;
        esac
    done < "$file"
}


## Entfernt das übergeordnete Verzeichnis
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
removeDir() {
    local directory="$1"
    if [ -d "$directory" ]; then
        # Versuchen das Verzeichnis zu entfernen. Evtl. Fehlermeldungen werden unterdrückt,
        # die sind in diesem Fall uninteressant.
        rmdir "$directory" 2>/dev/null || true
        if [ $# -eq 2 ]; then
            cdepShowMsg "$2"
        fi
    fi
}
## Speichert die Remove-Hooks (Paket config-Datei) für ein späteres Entfernen des Pakets
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
saveRemoveHooks() {
    # prüfen, ob überhaupt Remove-Hooks implementiert sind; wenn nicht, direkt abbrechen
    if ! usesRemoveHooks; then return 0; fi


    local src_conf="$1"
    local hook_dir; hook_dir="$(getCdeployDir "$P_OPT_SCOPE")/hooks"
    cdepSafeRun mkdir -p "$hook_dir" || \
            cdepShowError 1 "Verzeichnis für Paketinformationen konnte nicht erstellt werden."

    # Zieldatei z. B. "mypackage-1.0.hook"
    local hook_file; hook_file="$(cdepGetPackageInfo "-").hook"
    local hook_path="${hook_dir}/${hook_file}"

    # config-Datei (cdeploy.conf) kopieren und zip-en;
    # Datei ins Manifest aufnehmen
    cdepSafeRun cp "$src_conf" "$hook_path" || \
            cdepShowError 1 "Paketinformationen konnten nicht gespeichert werden."
    if cdepSafeRun gzip -f "$hook_path"; then
        manifestAppend "${hook_path}.gz" "hook"
    else
        manifestAppend "${hook_path}" "hook"
    fi

    cdepShowMsg "Paketinformationen gespeichert."
}


## Gbit eine Abschlusslinie aus, die das Ende der Skriptausgabe markiert
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
showBottomLine() {
    if isTrue "${_BOTTOM_LINE_SHOWN:=0}"; then return; fi
    declare -gr _BOTTOM_LINE_SHOWN=1

    # Ausgabe im Terminalfenster
    if isFalse $P_OPT_QUIET; then
        {
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo
        } > /dev/tty
    fi

    # Ausgabe für Umleitung in Datei
    if [ ! -t 1 ]; then
        echo "===================================================================================="
    fi
}


## Eine Warnmeldung ausgeben, wenn ein Paket Hooks definiert
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
showHookWarning() {
    if isTrue "$P_OPT_USEHOOKS"; then
        cdepShowMsg "DIE VERWENDUNG VON SKRIPTERWEITERUNGEN (\"HOOKS\") WURDE AKTIVIERT." "" ""
        return 0
    fi

    cdepShowMsg \
        "   WARNUNG" \
        "   –––––––" \
        "   DIESES PAKET ENTHÄLT SKRIPTERWEITERUNGEN DES ANBIETERS, DIE DIE FUNKTIONALITÄT" \
        "   VON CDEPLOY ERWEITERN. DIES IST KEIN FEHLER, STELLT ABER EIN POTENTIELLES" \
        "   SICHERHEITSRISIKO DAR, DA SO AUCH SCHADHAFTER CODE AUSGEFÜHRT WERDEN KÖNNTE." \
        "" \
        "   VERWENDEN SIE DAS PAKET DAHER NUR, WENN SIE ES VON EINER VERTRAUENSWÜRDIGEN" \
        "   QUELLE ERHALTEN HABEN!" \
        "" \
        "   Wenn Sie das Paket trotzdem verwenden möchten, tippen Sie \"ja\"." \
        "   Mit jeder anderen Eingabe brechen Sie den Vorgang ab."

    echo -n "   > "; IFS= read -r choice
    if [[ "$(toLowercase "$choice")" != "ja" ]]; then
        cdepShowMsg "" "   (Vorgang vom Benutzer abgebrochen.)" ""
        quit 2
    fi

    cdepShowMsg "" "   (Das Paket wird verwendet.)" "" ""
    return 0
}


## Titelzeile anzeigen
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
showTitle() {
    if isTrue "${_TITLE_SHOWN:=0}"; then return; fi
    declare -gr _TITLE_SHOWN=1

    local info="${_CDEP_SCRIPT_NAME} Version ${_CDEP_SCRIPT_VERSION} · Copyright (c) 2025 Christian Dorn · Alle Rechte vorbehalten. "

    if isTrue "$P_OUTPUT_FORMATTED"; then
        cdepShowMsg "" \
                "${_INVERT} ${info} ${_RESET}" \
                ""
    else
        cdepShowMsg "" \
                "====================================================================================" \
                "${info}" \
                "====================================================================================" \
                ""
    fi
}



## Anzeigen der gültigen Syntax und Abbrechen des Skripts
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
showSyntaxAndExit() {
    showTitle

    # optionale Fehlermeldungen ausgeben
    if [[ $# -gt 0 ]]; then
        cdepShowError 0 "$@"
        cdepShowMsg ""
    fi

    # Gültige Syntax ausgeben
    cdepShowMsg "Syntax: cdeploy help" \
            "        cdeploy create [opt...] <output>" \
            "        cdeploy info [--verbose] [--quiet] <package>" \
            "        cdeploy install --global|--local [--use-hooks] <package>" \
            "        cdeploy list" \
            "        cdeploy pack [--compressed] <archive>.cdp <package>" \
            "        cdeploy remove --global|--local [--use-hooks] [--force] <package>" \
            "        cdeploy version"

    quit 255
}


## sudo-Login
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
sudoLogin() {
    echo "   Für diese Aktion benötigen Sie Administratorrechte." > /dev/tty
    if [[ ! -t 1 ]]; then
        echo -n "   [sudo Kennwortabfrage]"
    fi

    # Trap, damit bei Strg-C sauber aufgeräumt wird (Kennwort-Variable löschen) und das
    # Skript mit einem Fehlercode (1) zurückkommt.
    local pw
    trap '[[ ! -t 1 ]] && echo > /dev/tty; cdepShowMsg "" "" "   (Abbruch durch den Benutzer)" ""; pw=""; unset pw; trap - INT; quit 1' INT

    while true; do
        # Passwort ohne Echo einlesen; bei Strg-C oder EOF liefert read !=0
        if ! IFS= read -rsp "   Bitte geben Sie ihr Kennwort ein (Strg-C zum Abbrechen): " pw; then
            if isTrue "$P_OPT_QUIET"; then echo > /dev/tty; fi
            cdepShowMsg "" "" "   (Abbruch durch den Benutzer)" ""
            quit 1
        fi

        # Passwort an sudo übergeben; Ausgaben unterdrücken
        if printf '%s\n' "$pw" | sudo -S -v >/dev/null 2>&1; then
            sleep 0.05
            # Erfolg. Passwort löschen und Funktion mit Erfolg beenden
            pw=""; unset pw; trap - INT
            if isTrue "$P_OPT_QUIET"; then echo > /dev/tty; fi
            cdepShowMsg "" "" ""
            P_USE_SUDO="sudo"
            return 0
        else
            # Fehler: Passwort löschen, Hinweis ausgeben, Schleife wiederholen
            pw=""; unset pw
            echo "" > /dev/tty
            echo "" > /dev/tty
            echo "   Falsches Kennwort, bitte versuchen Sie es nocheinmal. " > /dev/tty
            # Schleife läuft weiter
        fi
    done

    # Irgendetwas ist schiefgelaufen, an diese Stelle sollten wir nicht kommen!
    cdepShowMsg ""
    cdepShowError 1 "Ein unbekannter Fehler ist aufgetreten. cdeploy wird beendet."
}


## Ändert das erste Zeichen im übergeben String in einen Großbuchstaben
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
toCapitalized() {
    local text="$1"
    echo "${text^}"
}


## Ändert alle Zeichen im übergebenen Strnig in Kleinbuchstaben
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
toLowercase() {
    local text="$1"
    echo "${text,,}"
}


## Ändert alle Zeichen im übergebenen String in Großbuchstaben
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
toUppercase() {
    local text="$1"
    echo "${text^^}"
}


## Gibt Eingabe durch less, more oder cat aus – je nach Umgebung
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
usePager() {
    if isTrue "$P_USE_PAGER"; then
        # interaktiv: Ausgabe an Terminal
        if command -v less >/dev/null 2>&1; then
            less -rXF > /dev/tty
        elif command -v more >/dev/null 2>&1; then
            more > /dev/tty
        else
            cat > /dev/tty
        fi
    else
        # Ausgabe ohne Pager
        cat
    fi
}


## Prüft ob mindestens ein Hook definiert ist
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
usesHooks() {
    usesInstallHooks && return 0
    usesRemoveHooks && return 0
    return 1
}


## Prüft ob Install-Hooks verwendet werden
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
usesInstallHooks() {
    isOverridden hookPreInstall && return 0
    isOverridden hookPostInstall && return 0
    return 1
}


## Prüft ob Remove-Hooks verwendet werden
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
usesRemoveHooks() {
    isOverridden hookPreRemove && return 0
    echo "Kein Pre-Remove"
    isOverridden hookPostRemove && return 0
    echo "Kein Post-Remove"
    return 1
}


## Plausibilitätsprüfung für (Pfad-)Variablen (leer oder ungültige Zeichen)
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
validateVar() {
    local varname="$1"
    local value="${!varname}"
    if [[ -z "$value" ]]; then
        cdepShowError 1 "Variable $varname ist leer."
    fi
    if [[ "$value" =~ [^a-zA-Z0-9._/-] ]]; then
        cdepShowError 1 "Variable $varname enthält ungültige Zeichen." "$value"
    fi
}


## Liefert eine lesbare Form der übergebenen normalisierten Versionsnummer
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
versionReadable() {
    ver="$1"

    # Major = erstes Paar, Minor = zweites Paar, Patch = drittes Paar
    major=${ver%????}           # entfernt die letzten 4 Stellen -> Major+2 Stellen vom Ende
    rest=${ver#"${major}"}      # restliche 4 Stellen
    minor=${rest%??}            # die ersten 2 davon = Minor
    patch=${rest#"${minor}"}    # die letzten 2 = Patch

    # führende Nullen entfernen
    major=$(echo "$major" | sed 's/^0*//')
    minor=$(echo "$minor" | sed 's/^0*//')
    patch=$(echo "$patch" | sed 's/^0*//')

    # Wenn leer -> 0
    major=${major:-0}
    minor=${minor:-0}
    patch=${patch:-0}

    printf "%d.%d.%d\n" "$major" "$minor" "$patch"
}


## Liefert eine normalisierte Form der übergebenen Versionsnummer
## ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
versionNormalized() {
    ver="$1"

    # Aufteilen in drei Komponenten, fehlende = 0
    major=$(echo "$ver" | cut -d. -f1)
    minor=$(echo "$ver" | cut -d. -f2)
    patch=$(echo "$ver" | cut -d. -f3)

    major=${major:-0}
    minor=${minor:-0}
    patch=${patch:-0}

    printf "%02d%02d%02d" "$major" "$minor" "$patch"
}




## ========================================================================================
## Hooks definieren (leere Standard-Implementierungen)
## Hooks können in der Datei 'cdeploy.conf' im Installationspaket überschrieben werden und
## erweitern die Funktionalität von cdeploy.
## ========================================================================================
hookPreInstall()   { : __DEFAULT_HOOK__; }
hookPostInstall()  { : __DEFAULT_HOOK__; }
hookPreRemove()    { : __DEFAULT_HOOK__; }
hookPostRemove()   { : __DEFAULT_HOOK__; }




## ========================================================================================
## Aufruf der main()-Methode
## ========================================================================================
main "$@"
